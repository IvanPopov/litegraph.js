var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(t, w, m) {
  t != Array.prototype && t != Object.prototype && (t[w] = m.value);
};
$jscomp.getGlobal = function(t) {
  return "undefined" != typeof window && window === t ? t : "undefined" != typeof global && null != global ? global : t;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(t, w, m, y) {
  if (w) {
    m = $jscomp.global;
    t = t.split(".");
    for (y = 0; y < t.length - 1; y++) {
      var l = t[y];
      l in m || (m[l] = {});
      m = m[l];
    }
    t = t[t.length - 1];
    y = m[t];
    w = w(y);
    w != y && null != w && $jscomp.defineProperty(m, t, {configurable:!0, writable:!0, value:w});
  }
};
$jscomp.polyfill("Object.is", function(t) {
  return t ? t : function(t, m) {
    return t === m ? 0 !== t || 1 / t === 1 / m : t !== t && m !== m;
  };
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.includes", function(t) {
  return t ? t : function(t, m) {
    var w = this;
    w instanceof String && (w = String(w));
    var l = w.length;
    for (m = m || 0; m < l; m++) {
      if (w[m] == t || Object.is(w[m], t)) {
        return !0;
      }
    }
    return !1;
  };
}, "es7", "es3");
$jscomp.checkStringArgs = function(t, w, m) {
  if (null == t) {
    throw new TypeError("The 'this' value for String.prototype." + m + " must not be null or undefined");
  }
  if (w instanceof RegExp) {
    throw new TypeError("First argument to String.prototype." + m + " must not be a regular expression");
  }
  return t + "";
};
$jscomp.polyfill("String.prototype.includes", function(t) {
  return t ? t : function(t, m) {
    return -1 !== $jscomp.checkStringArgs(this, t, "includes").indexOf(t, m || 0);
  };
}, "es6", "es3");
$jscomp.owns = function(t, w) {
  return Object.prototype.hasOwnProperty.call(t, w);
};
$jscomp.polyfill("Object.assign", function(t) {
  return t ? t : function(t, m) {
    for (var w = 1; w < arguments.length; w++) {
      var l = arguments[w];
      if (l) {
        for (var x in l) {
          $jscomp.owns(l, x) && (t[x] = l[x]);
        }
      }
    }
    return t;
  };
}, "es6", "es3");
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
};
$jscomp.Symbol = function() {
  var t = 0;
  return function(w) {
    return $jscomp.SYMBOL_PREFIX + (w || "") + t++;
  };
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var t = $jscomp.global.Symbol.iterator;
  t || (t = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
  "function" != typeof Array.prototype[t] && $jscomp.defineProperty(Array.prototype, t, {configurable:!0, writable:!0, value:function() {
    return $jscomp.arrayIterator(this);
  }});
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(t) {
  var w = 0;
  return $jscomp.iteratorPrototype(function() {
    return w < t.length ? {done:!1, value:t[w++]} : {done:!0};
  });
};
$jscomp.iteratorPrototype = function(t) {
  $jscomp.initSymbolIterator();
  t = {next:t};
  t[$jscomp.global.Symbol.iterator] = function() {
    return this;
  };
  return t;
};
$jscomp.iteratorFromArray = function(t, w) {
  $jscomp.initSymbolIterator();
  t instanceof String && (t += "");
  var m = 0, y = {next:function() {
    if (m < t.length) {
      var l = m++;
      return {value:w(l, t[l]), done:!1};
    }
    y.next = function() {
      return {done:!0, value:void 0};
    };
    return y.next();
  }};
  y[Symbol.iterator] = function() {
    return y;
  };
  return y;
};
$jscomp.polyfill("Array.prototype.keys", function(t) {
  return t ? t : function() {
    return $jscomp.iteratorFromArray(this, function(t) {
      return t;
    });
  };
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.fill", function(t) {
  return t ? t : function(t, m, y) {
    var l = this.length || 0;
    0 > m && (m = Math.max(0, l + m));
    if (null == y || y > l) {
      y = l;
    }
    y = Number(y);
    0 > y && (y = Math.max(0, l + y));
    for (m = Number(m || 0); m < y; m++) {
      this[m] = t;
    }
    return this;
  };
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.values", function(t) {
  return t ? t : function() {
    return $jscomp.iteratorFromArray(this, function(t, m) {
      return m;
    });
  };
}, "es8", "es3");
$jscomp.polyfill("Object.values", function(t) {
  return t ? t : function(t) {
    var m = [], w;
    for (w in t) {
      $jscomp.owns(t, w) && m.push(t[w]);
    }
    return m;
  };
}, "es8", "es3");
$jscomp.polyfill("String.prototype.startsWith", function(t) {
  return t ? t : function(t, m) {
    var w = $jscomp.checkStringArgs(this, t, "startsWith");
    t += "";
    var l = w.length, x = t.length;
    m = Math.max(0, Math.min(m | 0, w.length));
    for (var A = 0; A < x && m < l;) {
      if (w[m++] != t[A++]) {
        return !1;
      }
    }
    return A >= x;
  };
}, "es6", "es3");
$jscomp.findInternal = function(t, w, m) {
  t instanceof String && (t = String(t));
  for (var y = t.length, l = 0; l < y; l++) {
    var x = t[l];
    if (w.call(m, x, l, t)) {
      return {i:l, v:x};
    }
  }
  return {i:-1, v:void 0};
};
$jscomp.polyfill("Array.prototype.findIndex", function(t) {
  return t ? t : function(t, m) {
    return $jscomp.findInternal(this, t, m).i;
  };
}, "es6", "es3");
(function(t) {
  function w(a, b, c) {
    b = void 0 === b ? 1 : b;
    c = void 0 === c ? 1 : c;
    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(a)) {
      return a = a.substring(1).split(""), 3 == a.length && (a = [a[0], a[0], a[1], a[1], a[2], a[2]]), a = "0x" + a.join(""), "rgba(" + [a >> 16 & 255, a >> 8 & 255, a & 255].map(function(a) {
        return Math.min(255, a * c);
      }).join(",") + ("," + b + ")");
    }
    throw Error("Bad Hex");
  }
  function m(a) {
    g.debug && console.log("Graph created");
    this.list_of_graphcanvas = null;
    this.clear();
    a && this.configure(a);
  }
  function y(a, b, c, e, d, f) {
    this.id = a;
    this.type = b;
    this.origin_id = c;
    this.origin_slot = e;
    this.target_id = d;
    this.target_slot = f;
    this._data = null;
    this._pos = new Float32Array(2);
  }
  function l(a) {
    this._ctor(a);
  }
  function x(a) {
    this._ctor(a);
  }
  function A(a, b) {
    this.offset = new Float32Array([0, 0]);
    this.scale = 1;
    this.max_scale = 10;
    this.min_scale = 0.1;
    this.onredraw = null;
    this.enabled = !0;
    this.last_mouse = [0, 0];
    this.element = null;
    this.visible_area = new Float32Array(4);
    a && (this.element = a, b || this.bindEvents(a));
  }
  function n(a, b, c) {
    this.options = c = c || {};
    this.background_image = n.DEFAULT_BACKGROUND_IMAGE;
    a && a.constructor === String && (a = document.querySelector(a));
    this.ds = new A;
    this.zoom_modify_alpha = !0;
    this.title_text_font = "" + g.NODE_TEXT_SIZE + "px Arial";
    this.inner_text_font = "normal " + g.NODE_SUBTEXT_SIZE + "px Arial";
    this.node_title_color = g.NODE_TITLE_COLOR;
    this.default_link_color = g.LINK_COLOR;
    this.default_connection_color = {input_off:"#778", input_on:"#7F7", output_off:"#778", output_on:"#7F7"};
    this.title_shadow_offset_y = this.title_shadow_offset_x = this.title_shadow_blur = 0;
    this.title_shadow_color = "#000";
    this.default_connection_color_byType = {number:"#26547C", float:"#26547C", uint:"#FFD166", boolean:"#EF476F", bool:"#EF476F", float3:"#FFD166", float2:"#45D592", float4:"#06D6A0", string:"#77F"};
    this.default_connection_color_byTypeOff = {number:"#26547C", float:"#26547C", uint:"#FFD166", boolean:"#EF476F", bool:"#EF476F", float3:"#FFD166", float2:"#45D592", float4:"#06D6A0", string:"#77F"};
    this.highquality_render = !0;
    this.use_gradients = !1;
    this.editor_alpha = 1;
    this.pause_rendering = !1;
    this.clear_background = !0;
    this.read_only = !1;
    this.render_only_selected = !0;
    this.live_mode = !1;
    this.allow_reconnect_links = this.allow_searchbox = this.allow_interaction = this.allow_dragnodes = this.allow_dragcanvas = this.show_info = !0;
    this.drag_mode = this.align_to_grid = !1;
    this.filter = this.dragging_rectangle = null;
    this.set_canvas_dirty_on_mouse_event = !0;
    this.always_render_background = !1;
    this.render_canvas_border = this.render_shadows = !0;
    this.render_connection_arrows = this.render_curved_connections = this.render_connections_border = this.render_connections_shadows = !1;
    this.render_collapsed_slots = !0;
    this.render_execution_order = !1;
    this.render_link_tooltip = this.render_title_colored = !0;
    this.render_link_center = !1;
    this.links_render_mode = g.SPLINE_LINK;
    this.mouse = [0, 0];
    this.canvas_mouse = this.graph_mouse = [0, 0];
    this.onAfterChange = this.onBeforeChange = this.onConnectingChange = this.onSelectionChange = this.onNodeMoved = this.onDrawLinkTooltip = this.onDrawOverlay = this.onDrawForeground = this.onDrawBackground = this.onMouse = this.onSearchBoxSelection = this.onSearchBox = null;
    this.connections_width = 2;
    this.round_radius = 3;
    this.over_link_center = this.node_widget = this.current_node = null;
    this.last_mouse_position = [0, 0];
    this.visible_area = this.ds.visible_area;
    this.visible_links = [];
    this.viewport = c.viewport || null;
    b && b.attachCanvas(this);
    this.setCanvas(a, c.skip_events);
    this.clear();
    c.skip_render || this.startRendering();
    this.autoresize = c.autoresize;
  }
  function G(a, b) {
    return Math.sqrt((b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]));
  }
  function B(a, b, c, e, d, f) {
    return c < a && c + d > a && e < b && e + f > b ? !0 : !1;
  }
  function H(a, b) {
    var c = a[0] + a[2], e = a[1] + a[3], d = b[1] + b[3];
    return a[0] > b[0] + b[2] || a[1] > d || c < b[0] || e < b[1] ? !1 : !0;
  }
  function F(a, b) {
    function c(a) {
      var c = parseInt(f.style.top);
      f.style.top = (c + a.deltaY * b.scroll_speed).toFixed() + "px";
      a.preventDefault();
      return !0;
    }
    this.options = b = b || {};
    var e = this;
    b.parentMenu && (b.parentMenu.constructor !== this.constructor ? (console.error("parentMenu must be of class ContextMenu, ignoring it"), b.parentMenu = null) : (this.parentMenu = b.parentMenu, this.parentMenu.lock = !0, this.parentMenu.current_submenu = this));
    var d = null;
    b.event && (d = b.event.constructor.name);
    "MouseEvent" !== d && "CustomEvent" !== d && "PointerEvent" !== d && (console.error("Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it. (" + d + ")"), b.event = null);
    var f = document.createElement("div");
    f.className = "litegraph litecontextmenu litemenubar-panel";
    b.className && (f.className += " " + b.className);
    f.style.minWidth = 100;
    f.style.minHeight = 100;
    f.style.pointerEvents = "none";
    setTimeout(function() {
      f.style.pointerEvents = "auto";
    }, 100);
    g.pointerListenerAdd(f, "up", function(a) {
      a.preventDefault();
      return !0;
    }, !0);
    f.addEventListener("contextmenu", function(a) {
      if (2 != a.button) {
        return !1;
      }
      a.preventDefault();
      return !1;
    }, !0);
    g.pointerListenerAdd(f, "down", function(a) {
      if (2 == a.button) {
        return e.close(), a.preventDefault(), !0;
      }
    }, !0);
    b.scroll_speed || (b.scroll_speed = 0.1);
    f.addEventListener("wheel", c, !0);
    f.addEventListener("mousewheel", c, !0);
    this.root = f;
    b.title && (d = document.createElement("div"), d.className = "litemenu-title", d.innerHTML = b.title, f.appendChild(d));
    for (var h = d = 0; h < a.length; h++) {
      var k = a.constructor == Array ? a[h] : h;
      null != k && k.constructor !== String && (k = void 0 === k.content ? String(k) : k.content);
      this.addItem(k, a[h], b);
      d++;
    }
    g.pointerListenerAdd(f, "enter", function(a) {
      f.closing_timer && clearTimeout(f.closing_timer);
    });
    a = document;
    b.event && (a = b.event.target.ownerDocument);
    a || (a = document);
    a.fullscreenElement ? a.fullscreenElement.appendChild(f) : a.body.appendChild(f);
    d = b.left || 0;
    a = b.top || 0;
    b.event && (d = b.event.clientX - 10, a = b.event.clientY - 10, b.title && (a -= 20), b.parentMenu && (d = b.parentMenu.root.getBoundingClientRect(), d = d.left + d.width), h = document.body.getBoundingClientRect(), k = f.getBoundingClientRect(), 0 == h.height && console.error("document.body height is 0. That is dangerous, set html,body { height: 100%; }"), h.width && d > h.width - k.width - 10 && (d = h.width - k.width - 10), h.height && a > h.height - k.height - 10 && (a = h.height - k.height - 
    10));
    f.style.left = d + "px";
    f.style.top = a + "px";
    b.scale && (f.style.transform = "scale(" + b.scale + ")");
  }
  function D(a) {
    this.points = a;
    this.nearest = this.selected = -1;
    this.size = null;
    this.must_update = !0;
    this.margin = 5;
  }
  var g = t.LiteGraph = {VERSION:0.4, CANVAS_GRID_SIZE:10, NODE_TITLE_HEIGHT:30, NODE_TITLE_TEXT_Y:20, NODE_SLOT_HEIGHT:20, NODE_WIDGET_HEIGHT:20, NODE_WIDTH:140, NODE_MIN_WIDTH:50, NODE_COLLAPSED_RADIUS:10, NODE_COLLAPSED_WIDTH:80, NODE_TITLE_COLOR:"#999", NODE_SELECTED_TITLE_COLOR:"#FFF", NODE_TEXT_SIZE:14, NODE_TEXT_COLOR:"#AAA", NODE_SUBTEXT_SIZE:12, NODE_DEFAULT_COLOR:"#333", NODE_DEFAULT_BGCOLOR:"#353535", NODE_DEFAULT_BOXCOLOR:"#666", NODE_DEFAULT_SHAPE:"box", NODE_BOX_OUTLINE_COLOR:"#FFF", 
  DEFAULT_SHADOW_COLOR:"rgba(0,0,0,0.5)", DEFAULT_GROUP_FONT:24, WIDGET_BGCOLOR:"#222", WIDGET_OUTLINE_COLOR:"#666", WIDGET_TEXT_COLOR:"#DDD", WIDGET_SECONDARY_TEXT_COLOR:"#999", LINK_COLOR:"#9A9", EVENT_LINK_COLOR:"#A86", CONNECTING_LINK_COLOR:"#AFA", MAX_NUMBER_OF_NODES:1000, DEFAULT_POSITION:[100, 100], VALID_SHAPES:["default", "box", "round", "card"], BOX_SHAPE:1, ROUND_SHAPE:2, CIRCLE_SHAPE:3, CARD_SHAPE:4, ARROW_SHAPE:5, GRID_SHAPE:6, INPUT:1, OUTPUT:2, EVENT:-1, ACTION:-1, NODE_MODES:["Always", 
  "On Event", "Never", "On Trigger"], NODE_MODES_COLORS:["#666", "#422", "#333", "#224", "#626"], ALWAYS:0, ON_EVENT:1, NEVER:2, ON_TRIGGER:3, UP:1, DOWN:2, LEFT:3, RIGHT:4, CENTER:5, LINK_RENDER_MODES:["Straight", "Linear", "Spline"], STRAIGHT_LINK:0, LINEAR_LINK:1, SPLINE_LINK:2, NORMAL_TITLE:0, NO_TITLE:1, TRANSPARENT_TITLE:2, AUTOHIDE_TITLE:3, VERTICAL_LAYOUT:"vertical", proxy:null, node_images_path:"", debug:!1, catch_exceptions:!0, throw_errors:!0, allow_scripts:!1, registered_node_types:{}, 
  node_types_by_file_extension:{}, Nodes:{}, Globals:{}, searchbox_extras:{}, auto_sort_node_types:!1, node_box_coloured_when_on:!1, node_box_coloured_by_mode:!1, dialog_close_on_mouse_leave:!0, dialog_close_on_mouse_leave_delay:500, shift_click_do_break_link_from:!1, click_do_break_link_to:!1, search_hide_on_mouse_leave:!0, search_filter_enabled:!1, search_show_all_on_open:!0, auto_load_slot_types:!1, registered_slot_in_types:{}, registered_slot_out_types:{}, slot_types_in:[], slot_types_out:[], 
  slot_types_default_in:[], slot_types_default_out:[], alt_drag_do_clone_nodes:!1, do_add_triggers_slots:!1, allow_multi_output_for_events:!0, draw_invisible_connections:!1, middle_click_slot_add_default_node:!1, middle_click_canvas_dragging:!1, release_link_on_empty_shows_menu:!1, pointerevents_method:"mouse", registerNodeType:function(a, b) {
    if (!b.prototype) {
      throw "Cannot register a simple object, it must be a class with a prototype";
    }
    b.type = a;
    g.debug && console.log("Node registered: " + a);
    a.split("/");
    var c = b.name, e = a.lastIndexOf("/");
    b.category = a.substr(0, e);
    b.title || (b.title = c);
    if (b.prototype) {
      for (var d in l.prototype) {
        b.prototype[d] || (b.prototype[d] = l.prototype[d]);
      }
    }
    if (e = this.registered_node_types[a]) {
      console.log("replacing node type: " + a);
    } else {
      if (Object.hasOwnProperty(b.prototype, "shape") || Object.defineProperty(b.prototype, "shape", {set:function(a) {
        switch(a) {
          case "default":
            delete this._shape;
            break;
          case "box":
            this._shape = g.BOX_SHAPE;
            break;
          case "round":
            this._shape = g.ROUND_SHAPE;
            break;
          case "circle":
            this._shape = g.CIRCLE_SHAPE;
            break;
          case "card":
            this._shape = g.CARD_SHAPE;
            break;
          default:
            this._shape = a;
        }
      }, get:function(a) {
        return this._shape;
      }, enumerable:!0, configurable:!0}), b.prototype.onPropertyChange && console.warn("LiteGraph node class " + a + " has onPropertyChange method, it must be called onPropertyChanged with d at the end"), b.supported_extensions) {
        for (d in b.supported_extensions) {
          var f = b.supported_extensions[d];
          f && f.constructor === String && (this.node_types_by_file_extension[f.toLowerCase()] = b);
        }
      }
    }
    this.registered_node_types[a] = b;
    b.constructor.name && (this.Nodes[c] = b);
    if (g.onNodeTypeRegistered) {
      g.onNodeTypeRegistered(a, b);
    }
    if (e && g.onNodeTypeReplaced) {
      g.onNodeTypeReplaced(a, b, e);
    }
    b.prototype.onPropertyChange && console.warn("LiteGraph node class " + a + " has onPropertyChange method, it must be called onPropertyChanged with d at the end");
    if (b.supported_extensions) {
      for (d = 0; d < b.supported_extensions.length; d++) {
        (f = b.supported_extensions[d]) && f.constructor === String && (this.node_types_by_file_extension[f.toLowerCase()] = b);
      }
    }
    this.auto_load_slot_types && (nodeTmp = new b(b.title || "tmpnode"));
  }, unregisterNodeType:function(a) {
    var b = a.constructor === String ? this.registered_node_types[a] : a;
    if (!b) {
      throw "node type not found: " + a;
    }
    delete this.registered_node_types[b.type];
    b.constructor.name && delete this.Nodes[b.constructor.name];
  }, registerNodeAndSlotType:function(a, b, c) {
    c = c || !1;
    a = (a.constructor === String && "anonymous" !== this.registered_node_types[a] ? this.registered_node_types[a] : a).constructor.type;
    b = "string" == typeof b ? b.split(",") : b == this.EVENT || b == this.ACTION ? ["_event_"] : ["*"];
    for (var e = 0; e < b.length; ++e) {
      var d = b[e];
      "" === d && (d = "*");
      var f = c ? "registered_slot_out_types" : "registered_slot_in_types";
      "undefined" == typeof this[f][d] && (this[f][d] = {nodes:[]});
      this[f][d].nodes.push(a);
      c ? this.slot_types_out.includes(d.toLowerCase()) || (this.slot_types_out.push(d.toLowerCase()), this.slot_types_out.sort()) : this.slot_types_in.includes(d.toLowerCase()) || (this.slot_types_in.push(d.toLowerCase()), this.slot_types_in.sort());
    }
  }, wrapFunctionAsNode:function(a, b, c, e, d) {
    for (var f = Array(b.length), h = "", k = g.getParameterNames(b), q = 0; q < k.length; ++q) {
      h += "this.addInput('" + k[q] + "'," + (c && c[q] ? "'" + c[q] + "'" : "0") + ");\n";
    }
    h += "this.addOutput('out'," + (e ? "'" + e + "'" : 0) + ");\n";
    d && (h += "this.properties = " + JSON.stringify(d) + ";\n");
    c = Function(h);
    c.title = a.split("/").pop();
    c.desc = "Generated from " + b.name;
    c.prototype.onExecute = function() {
      for (var a = 0; a < f.length; ++a) {
        f[a] = this.getInputData(a);
      }
      a = b.apply(this, f);
      this.setOutputData(0, a);
    };
    this.registerNodeType(a, c);
  }, clearRegisteredTypes:function() {
    this.registered_node_types = {};
    this.node_types_by_file_extension = {};
    this.Nodes = {};
    this.searchbox_extras = {};
  }, addNodeMethod:function(a, b) {
    l.prototype[a] = b;
    for (var c in this.registered_node_types) {
      var e = this.registered_node_types[c];
      e.prototype[a] && (e.prototype["_" + a] = e.prototype[a]);
      e.prototype[a] = b;
    }
  }, createNode:function(a, b, c) {
    var e = this.registered_node_types[a];
    if (!e) {
      return g.debug && console.log('GraphNode type "' + a + '" not registered.'), null;
    }
    b = b || e.title || a;
    var d = null;
    if (g.catch_exceptions) {
      try {
        d = new e(b);
      } catch (h) {
        return console.error(h), null;
      }
    } else {
      d = new e(b);
    }
    d.type = a;
    !d.title && b && (d.title = b);
    d.properties || (d.properties = {});
    d.properties_info || (d.properties_info = []);
    d.flags || (d.flags = {});
    d.size || (d.size = d.computeSize());
    d.pos || (d.pos = g.DEFAULT_POSITION.concat());
    d.mode || (d.mode = g.ALWAYS);
    if (c) {
      for (var f in c) {
        d[f] = c[f];
      }
    }
    if (d.onNodeCreated) {
      d.onNodeCreated();
    }
    return d;
  }, getNodeType:function(a) {
    return this.registered_node_types[a];
  }, getNodeTypesInCategory:function(a, b) {
    var c = [], e;
    for (e in this.registered_node_types) {
      var d = this.registered_node_types[e];
      d.filter == b && ("" == a ? null == d.category && c.push(d) : d.category == a && c.push(d));
    }
    this.auto_sort_node_types && c.sort(function(a, b) {
      return a.title.localeCompare(b.title);
    });
    return c;
  }, getNodeTypesCategories:function(a) {
    var b = {"":1}, c;
    for (c in this.registered_node_types) {
      var e = this.registered_node_types[c];
      e.category && !e.skip_list && e.filter == a && (b[e.category] = 1);
    }
    a = [];
    for (c in b) {
      a.push(c);
    }
    return this.auto_sort_node_types ? a.sort() : a;
  }, reloadNodes:function(a) {
    for (var b = document.getElementsByTagName("script"), c = [], e = 0; e < b.length; e++) {
      c.push(b[e]);
    }
    b = document.getElementsByTagName("head")[0];
    a = document.location.href + a;
    for (e = 0; e < c.length; e++) {
      var d = c[e].src;
      if (d && d.substr(0, a.length) == a) {
        try {
          g.debug && console.log("Reloading: " + d);
          var f = document.createElement("script");
          f.type = "text/javascript";
          f.src = d;
          b.appendChild(f);
          b.removeChild(c[e]);
        } catch (h) {
          if (g.throw_errors) {
            throw h;
          }
          g.debug && console.log("Error while reloading " + d);
        }
      }
    }
    g.debug && console.log("Nodes reloaded");
  }, cloneObject:function(a, b) {
    if (null == a) {
      return null;
    }
    a = JSON.parse(JSON.stringify(a));
    if (!b) {
      return a;
    }
    for (var c in a) {
      b[c] = a[c];
    }
    return b;
  }, isValidConnection:function(a, b) {
    if ("" == a || "*" === a) {
      a = 0;
    }
    if ("" == b || "*" === b) {
      b = 0;
    }
    if (!a || !b || a == b || a == g.EVENT && b == g.ACTION) {
      return !0;
    }
    a = String(a);
    b = String(b);
    a = a.toLowerCase();
    b = b.toLowerCase();
    if (-1 == a.indexOf(",") && -1 == b.indexOf(",")) {
      return a == b;
    }
    a = a.split(",");
    b = b.split(",");
    for (var c = 0; c < a.length; ++c) {
      for (var e = 0; e < b.length; ++e) {
        if (this.isValidConnection(a[c], b[e])) {
          return !0;
        }
      }
    }
    return !1;
  }, registerSearchboxExtra:function(a, b, c) {
    this.searchbox_extras[b.toLowerCase()] = {type:a, desc:b, data:c};
  }, fetchFile:function(a, b, c, e) {
    if (!a) {
      return null;
    }
    b = b || "text";
    if (a.constructor === String) {
      return "http" == a.substr(0, 4) && g.proxy && (a = g.proxy + a.substr(a.indexOf(":") + 3)), fetch(a).then(function(a) {
        if (!a.ok) {
          throw Error("File not found");
        }
        if ("arraybuffer" == b) {
          return a.arrayBuffer();
        }
        if ("text" == b || "string" == b) {
          return a.text();
        }
        if ("json" == b) {
          return a.json();
        }
        if ("blob" == b) {
          return a.blob();
        }
      }).then(function(a) {
        c && c(a);
      }).catch(function(b) {
        console.error("error fetching file:", a);
        e && e(b);
      });
    }
    if (a.constructor === File || a.constructor === Blob) {
      var d = new FileReader;
      d.onload = function(a) {
        a = a.target.result;
        "json" == b && (a = JSON.parse(a));
        c && c(a);
      };
      if ("arraybuffer" == b) {
        return d.readAsArrayBuffer(a);
      }
      if ("text" == b || "json" == b) {
        return d.readAsText(a);
      }
      if ("blob" == b) {
        return d.readAsBinaryString(a);
      }
    }
    return null;
  }};
  g.getTime = "undefined" != typeof performance ? performance.now.bind(performance) : "undefined" != typeof Date && Date.now ? Date.now.bind(Date) : "undefined" != typeof process ? function() {
    var a = process.hrtime();
    return 0.001 * a[0] + 1e-6 * a[1];
  } : function() {
    return (new Date).getTime();
  };
  t.LGraph = g.LGraph = m;
  m.supported_types = ["number", "string", "boolean"];
  m.prototype.getSupportedTypes = function() {
    return this.supported_types || m.supported_types;
  };
  m.STATUS_STOPPED = 1;
  m.STATUS_RUNNING = 2;
  m.prototype.clear = function() {
    this.stop();
    this.status = m.STATUS_STOPPED;
    this.last_link_id = this.last_node_id = 0;
    this._version = -1;
    if (this._nodes) {
      for (var a = 0; a < this._nodes.length; ++a) {
        var b = this._nodes[a];
        if (b.onRemoved) {
          b.onRemoved();
        }
      }
    }
    this._nodes = [];
    this._nodes_by_id = {};
    this._nodes_in_order = [];
    this._nodes_executable = null;
    this._groups = [];
    this.links = {};
    this.iteration = 0;
    this.config = {};
    this.vars = {};
    this.extra = {};
    this.fixedtime = this.runningtime = this.globaltime = 0;
    this.elapsed_time = this.fixedtime_lapse = 0.01;
    this.starttime = this.last_update_time = 0;
    this.catch_errors = !0;
    this.nodes_executing = [];
    this.nodes_actioning = [];
    this.nodes_executedAction = [];
    this.inputs = {};
    this.outputs = {};
    this.change();
    this.sendActionToCanvas("clear");
  };
  m.prototype.attachCanvas = function(a) {
    if (a.constructor != n) {
      throw "attachCanvas expects a LGraphCanvas instance";
    }
    a.graph && a.graph != this && a.graph.detachCanvas(a);
    a.graph = this;
    this.list_of_graphcanvas || (this.list_of_graphcanvas = []);
    this.list_of_graphcanvas.push(a);
  };
  m.prototype.detachCanvas = function(a) {
    if (this.list_of_graphcanvas) {
      var b = this.list_of_graphcanvas.indexOf(a);
      -1 != b && (a.graph = null, this.list_of_graphcanvas.splice(b, 1));
    }
  };
  m.prototype.start = function(a) {
    if (this.status != m.STATUS_RUNNING) {
      this.status = m.STATUS_RUNNING;
      if (this.onPlayEvent) {
        this.onPlayEvent();
      }
      this.sendEventToAllNodes("onStart");
      this.last_update_time = this.starttime = g.getTime();
      a = a || 0;
      var b = this;
      if (0 == a && "undefined" != typeof window && window.requestAnimationFrame) {
        var c = function() {
          if (-1 == b.execution_timer_id) {
            window.requestAnimationFrame(c);
            if (b.onBeforeStep) {
              b.onBeforeStep();
            }
            b.runStep(1, !b.catch_errors);
            if (b.onAfterStep) {
              b.onAfterStep();
            }
          }
        };
        this.execution_timer_id = -1;
        c();
      } else {
        this.execution_timer_id = setInterval(function() {
          if (b.onBeforeStep) {
            b.onBeforeStep();
          }
          b.runStep(1, !b.catch_errors);
          if (b.onAfterStep) {
            b.onAfterStep();
          }
        }, a);
      }
    }
  };
  m.prototype.stop = function() {
    if (this.status != m.STATUS_STOPPED) {
      this.status = m.STATUS_STOPPED;
      if (this.onStopEvent) {
        this.onStopEvent();
      }
      null != this.execution_timer_id && (-1 != this.execution_timer_id && clearInterval(this.execution_timer_id), this.execution_timer_id = null);
      this.sendEventToAllNodes("onStop");
    }
  };
  m.prototype.runStep = function(a, b, c) {
    a = a || 1;
    var e = g.getTime();
    this.globaltime = 0.001 * (e - this.starttime);
    var d = this._nodes_executable ? this._nodes_executable : this._nodes;
    if (d) {
      c = c || d.length;
      if (b) {
        for (var f = 0; f < a; f++) {
          for (var h = 0; h < c; ++h) {
            var k = d[h];
            k.mode == g.ALWAYS && k.onExecute && k.doExecute();
          }
          this.fixedtime += this.fixedtime_lapse;
          if (this.onExecuteStep) {
            this.onExecuteStep();
          }
        }
        if (this.onAfterExecute) {
          this.onAfterExecute();
        }
      } else {
        try {
          for (f = 0; f < a; f++) {
            for (h = 0; h < c; ++h) {
              if (k = d[h], k.mode == g.ALWAYS && k.onExecute) {
                k.onExecute();
              }
            }
            this.fixedtime += this.fixedtime_lapse;
            if (this.onExecuteStep) {
              this.onExecuteStep();
            }
          }
          if (this.onAfterExecute) {
            this.onAfterExecute();
          }
          this.errors_in_execution = !1;
        } catch (q) {
          this.errors_in_execution = !0;
          if (g.throw_errors) {
            throw q;
          }
          g.debug && console.log("Error during execution: " + q);
          this.stop();
        }
      }
      a = g.getTime();
      e = a - e;
      0 == e && (e = 1);
      this.execution_time = 0.001 * e;
      this.globaltime += 0.001 * e;
      this.iteration += 1;
      this.elapsed_time = 0.001 * (a - this.last_update_time);
      this.last_update_time = a;
      this.nodes_executing = [];
      this.nodes_actioning = [];
      this.nodes_executedAction = [];
    }
  };
  m.prototype.updateExecutionOrder = function() {
    this._nodes_in_order = this.computeExecutionOrder(!1);
    this._nodes_executable = [];
    for (var a = 0; a < this._nodes_in_order.length; ++a) {
      this._nodes_in_order[a].onExecute && this._nodes_executable.push(this._nodes_in_order[a]);
    }
  };
  m.prototype.computeExecutionOrder = function(a, b) {
    for (var c = [], e = [], d = {}, f = {}, h = {}, k = 0, q = this._nodes.length; k < q; ++k) {
      var r = this._nodes[k];
      if (!a || r.onExecute) {
        d[r.id] = r;
        var u = 0;
        if (r.inputs) {
          for (var p = 0, n = r.inputs.length; p < n; p++) {
            r.inputs[p] && null != r.inputs[p].link && (u += 1);
          }
        }
        0 == u ? (e.push(r), b && (r._level = 1)) : (b && (r._level = 0), h[r.id] = u);
      }
    }
    for (; 0 != e.length;) {
      if (r = e.shift(), c.push(r), delete d[r.id], r.outputs) {
        for (k = 0; k < r.outputs.length; k++) {
          if (a = r.outputs[k], null != a && null != a.links && 0 != a.links.length) {
            for (p = 0; p < a.links.length; p++) {
              (q = this.links[a.links[p]]) && !f[q.id] && (u = this.getNodeById(q.target_id), null == u ? f[q.id] = !0 : (b && (!u._level || u._level <= r._level) && (u._level = r._level + 1), f[q.id] = !0, --h[u.id], 0 == h[u.id] && e.push(u)));
            }
          }
        }
      }
    }
    for (k in d) {
      c.push(d[k]);
    }
    c.length != this._nodes.length && g.debug && console.warn("something went wrong, nodes missing");
    q = c.length;
    for (k = 0; k < q; ++k) {
      c[k].order = k;
    }
    c = c.sort(function(a, b) {
      var c = a.constructor.priority || a.priority || 0, d = b.constructor.priority || b.priority || 0;
      return c == d ? a.order - b.order : c - d;
    });
    for (k = 0; k < q; ++k) {
      c[k].order = k;
    }
    return c;
  };
  m.prototype.getAncestors = function(a) {
    for (var b = [], c = [a], e = {}; c.length;) {
      var d = c.shift();
      if (d.inputs) {
        e[d.id] || d == a || (e[d.id] = !0, b.push(d));
        for (var f = 0; f < d.inputs.length; ++f) {
          var h = d.getInputNode(f);
          h && -1 == b.indexOf(h) && c.push(h);
        }
      }
    }
    b.sort(function(a, b) {
      return a.order - b.order;
    });
    return b;
  };
  m.prototype.arrange = function(a, b) {
    a = a || 100;
    for (var c = this.computeExecutionOrder(!1, !0), e = [], d = 0; d < c.length; ++d) {
      var f = c[d], h = f._level || 1;
      e[h] || (e[h] = []);
      e[h].push(f);
    }
    c = a;
    for (d = 0; d < e.length; ++d) {
      if (h = e[d]) {
        for (var k = 100, q = a + g.NODE_TITLE_HEIGHT, r = 0; r < h.length; ++r) {
          f = h[r], f.pos[0] = b == g.VERTICAL_LAYOUT ? q : c, f.pos[1] = b == g.VERTICAL_LAYOUT ? c : q, max_size_index = b == g.VERTICAL_LAYOUT ? 1 : 0, f.size[max_size_index] > k && (k = f.size[max_size_index]), node_size_index = b == g.VERTICAL_LAYOUT ? 0 : 1, q += f.size[node_size_index] + a + g.NODE_TITLE_HEIGHT;
        }
        c += k + a;
      }
    }
    this.setDirtyCanvas(!0, !0);
  };
  m.prototype.getTime = function() {
    return this.globaltime;
  };
  m.prototype.getFixedTime = function() {
    return this.fixedtime;
  };
  m.prototype.getElapsedTime = function() {
    return this.elapsed_time;
  };
  m.prototype.sendEventToAllNodes = function(a, b, c) {
    c = c || g.ALWAYS;
    var e = this._nodes_in_order ? this._nodes_in_order : this._nodes;
    if (e) {
      for (var d = 0, f = e.length; d < f; ++d) {
        var h = e[d];
        if (h.constructor === g.Subgraph && "onExecute" != a) {
          h.mode == c && h.sendEventToAllNodes(a, b, c);
        } else {
          if (h[a] && h.mode == c) {
            if (void 0 === b) {
              h[a]();
            } else {
              if (b && b.constructor === Array) {
                h[a].apply(h, b);
              } else {
                h[a](b);
              }
            }
          }
        }
      }
    }
  };
  m.prototype.sendActionToCanvas = function(a, b) {
    if (this.list_of_graphcanvas) {
      for (var c = 0; c < this.list_of_graphcanvas.length; ++c) {
        var e = this.list_of_graphcanvas[c];
        e[a] && e[a].apply(e, b);
      }
    }
  };
  m.prototype.add = function(a, b) {
    if (a) {
      if (a.constructor === x) {
        this._groups.push(a), this.setDirtyCanvas(!0), this.change(), a.graph = this, this._version++;
      } else {
        -1 != a.id && null != this._nodes_by_id[a.id] && (console.warn("LiteGraph: there is already a node with this ID, changing it"), a.id = ++this.last_node_id);
        if (this._nodes.length >= g.MAX_NUMBER_OF_NODES) {
          throw "LiteGraph: max number of nodes in a graph reached";
        }
        null == a.id || -1 == a.id ? a.id = ++this.last_node_id : this.last_node_id < a.id && (this.last_node_id = a.id);
        a.graph = this;
        this._version++;
        this._nodes.push(a);
        this._nodes_by_id[a.id] = a;
        if (a.onAdded) {
          a.onAdded(this);
        }
        this.config.align_to_grid && a.alignToGrid();
        b || this.updateExecutionOrder();
        if (this.onNodeAdded) {
          this.onNodeAdded(a);
        }
        this.setDirtyCanvas(!0);
        this.change();
        return a;
      }
    }
  };
  m.prototype.remove = function(a) {
    if (a.constructor === g.LGraphGroup) {
      var b = this._groups.indexOf(a);
      -1 != b && this._groups.splice(b, 1);
      a.graph = null;
      this._version++;
      this.setDirtyCanvas(!0, !0);
      this.change();
    } else {
      if (null != this._nodes_by_id[a.id] && !a.ignore_remove) {
        this.beforeChange();
        if (a.inputs) {
          for (b = 0; b < a.inputs.length; b++) {
            var c = a.inputs[b];
            null != c.link && a.disconnectInput(b);
          }
        }
        if (a.outputs) {
          for (b = 0; b < a.outputs.length; b++) {
            c = a.outputs[b], null != c.links && c.links.length && a.disconnectOutput(b);
          }
        }
        if (a.onRemoved) {
          a.onRemoved();
        }
        a.graph = null;
        this._version++;
        if (this.list_of_graphcanvas) {
          for (b = 0; b < this.list_of_graphcanvas.length; ++b) {
            c = this.list_of_graphcanvas[b], c.selected_nodes[a.id] && delete c.selected_nodes[a.id], c.node_dragged == a && (c.node_dragged = null);
          }
        }
        b = this._nodes.indexOf(a);
        -1 != b && this._nodes.splice(b, 1);
        delete this._nodes_by_id[a.id];
        if (this.onNodeRemoved) {
          this.onNodeRemoved(a);
        }
        this.sendActionToCanvas("checkPanels");
        this.setDirtyCanvas(!0, !0);
        this.afterChange();
        this.change();
        this.updateExecutionOrder();
      }
    }
  };
  m.prototype.getNodeById = function(a) {
    return null == a ? null : this._nodes_by_id[a];
  };
  m.prototype.findNodesByClass = function(a, b) {
    b = b || [];
    for (var c = b.length = 0, e = this._nodes.length; c < e; ++c) {
      this._nodes[c].constructor === a && b.push(this._nodes[c]);
    }
    return b;
  };
  m.prototype.findNodesByType = function(a, b) {
    a = a.toLowerCase();
    b = b || [];
    for (var c = b.length = 0, e = this._nodes.length; c < e; ++c) {
      this._nodes[c].type.toLowerCase() == a && b.push(this._nodes[c]);
    }
    return b;
  };
  m.prototype.findNodeByTitle = function(a) {
    for (var b = 0, c = this._nodes.length; b < c; ++b) {
      if (this._nodes[b].title == a) {
        return this._nodes[b];
      }
    }
    return null;
  };
  m.prototype.findNodesByTitle = function(a) {
    for (var b = [], c = 0, e = this._nodes.length; c < e; ++c) {
      this._nodes[c].title == a && b.push(this._nodes[c]);
    }
    return b;
  };
  m.prototype.getNodeOnPos = function(a, b, c, e) {
    c = c || this._nodes;
    for (var d = c.length - 1; 0 <= d; d--) {
      var f = c[d];
      if (f.isPointInside(a, b, e)) {
        return f;
      }
    }
    return null;
  };
  m.prototype.getNodesOnPos = function(a, b, c, e) {
    c = c || this._nodes;
    for (var d = [], f = c.length - 1; 0 <= f; f--) {
      var h = c[f];
      h.isPointInside(a, b, e) && d.push(h);
    }
    return d;
  };
  m.prototype.getGroupOnPos = function(a, b) {
    for (var c = this._groups.length - 1; 0 <= c; c--) {
      var e = this._groups[c];
      if (e.isPointInside(a, b, 2, !0)) {
        return e;
      }
    }
    return null;
  };
  m.prototype.checkNodeTypes = function() {
    for (var a = 0; a < this._nodes.length; a++) {
      var b = this._nodes[a];
      if (b.constructor != g.registered_node_types[b.type]) {
        console.log("node being replaced by newer version: " + b.type);
        var c = g.createNode(b.type);
        this._nodes[a] = c;
        c.configure(b.serialize());
        c.graph = this;
        this._nodes_by_id[c.id] = c;
        b.inputs && (c.inputs = b.inputs.concat());
        b.outputs && (c.outputs = b.outputs.concat());
      }
    }
    this.updateExecutionOrder();
  };
  m.prototype.onAction = function(a, b, c) {
    this._input_nodes = this.findNodesByClass(g.GraphInput, this._input_nodes);
    for (var e = 0; e < this._input_nodes.length; ++e) {
      var d = this._input_nodes[e];
      if (d.properties.name == a) {
        d.actionDo(a, b, c);
        break;
      }
    }
  };
  m.prototype.trigger = function(a, b) {
    if (this.onTrigger) {
      this.onTrigger(a, b);
    }
  };
  m.prototype.addInput = function(a, b, c) {
    if (!this.inputs[a]) {
      this.beforeChange();
      this.inputs[a] = {name:a, type:b, value:c};
      this._version++;
      this.afterChange();
      if (this.onInputAdded) {
        this.onInputAdded(a, b);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
  };
  m.prototype.setInputData = function(a, b) {
    if (a = this.inputs[a]) {
      a.value = b;
    }
  };
  m.prototype.getInputData = function(a) {
    return (a = this.inputs[a]) ? a.value : null;
  };
  m.prototype.renameInput = function(a, b) {
    if (b != a) {
      if (!this.inputs[a]) {
        return !1;
      }
      if (this.inputs[b]) {
        return console.error("there is already one input with that name"), !1;
      }
      this.inputs[b] = this.inputs[a];
      delete this.inputs[a];
      this._version++;
      if (this.onInputRenamed) {
        this.onInputRenamed(a, b);
      }
      if (this.onInputsOutputsChange) {
        this.onInputsOutputsChange();
      }
    }
  };
  m.prototype.changeInputType = function(a, b) {
    if (!this.inputs[a]) {
      return !1;
    }
    if (!this.inputs[a].type || String(this.inputs[a].type).toLowerCase() != String(b).toLowerCase()) {
      if (this.inputs[a].type = b, this._version++, this.onInputTypeChanged) {
        this.onInputTypeChanged(a, b);
      }
    }
  };
  m.prototype.removeInput = function(a) {
    if (!this.inputs[a]) {
      return !1;
    }
    delete this.inputs[a];
    this._version++;
    if (this.onInputRemoved) {
      this.onInputRemoved(a);
    }
    if (this.onInputsOutputsChange) {
      this.onInputsOutputsChange();
    }
    return !0;
  };
  m.prototype.addOutput = function(a, b, c) {
    this.outputs[a] = {name:a, type:b, value:c};
    this._version++;
    if (this.onOutputAdded) {
      this.onOutputAdded(a, b);
    }
    if (this.onInputsOutputsChange) {
      this.onInputsOutputsChange();
    }
  };
  m.prototype.setOutputData = function(a, b) {
    if (a = this.outputs[a]) {
      a.value = b;
    }
  };
  m.prototype.getOutputData = function(a) {
    return (a = this.outputs[a]) ? a.value : null;
  };
  m.prototype.renameOutput = function(a, b) {
    if (!this.outputs[a]) {
      return !1;
    }
    if (this.outputs[b]) {
      return console.error("there is already one output with that name"), !1;
    }
    this.outputs[b] = this.outputs[a];
    delete this.outputs[a];
    this._version++;
    if (this.onOutputRenamed) {
      this.onOutputRenamed(a, b);
    }
    if (this.onInputsOutputsChange) {
      this.onInputsOutputsChange();
    }
  };
  m.prototype.changeOutputType = function(a, b) {
    if (!this.outputs[a]) {
      return !1;
    }
    if (!this.outputs[a].type || String(this.outputs[a].type).toLowerCase() != String(b).toLowerCase()) {
      if (this.outputs[a].type = b, this._version++, this.onOutputTypeChanged) {
        this.onOutputTypeChanged(a, b);
      }
    }
  };
  m.prototype.removeOutput = function(a) {
    if (!this.outputs[a]) {
      return !1;
    }
    delete this.outputs[a];
    this._version++;
    if (this.onOutputRemoved) {
      this.onOutputRemoved(a);
    }
    if (this.onInputsOutputsChange) {
      this.onInputsOutputsChange();
    }
    return !0;
  };
  m.prototype.triggerInput = function(a, b) {
    a = this.findNodesByTitle(a);
    for (var c = 0; c < a.length; ++c) {
      a[c].onTrigger(b);
    }
  };
  m.prototype.setCallback = function(a, b) {
    a = this.findNodesByTitle(a);
    for (var c = 0; c < a.length; ++c) {
      a[c].setTrigger(b);
    }
  };
  m.prototype.beforeChange = function(a) {
    if (this.onBeforeChange) {
      this.onBeforeChange(this, a);
    }
    this.sendActionToCanvas("onBeforeChange", this);
  };
  m.prototype.afterChange = function(a) {
    if (this.onAfterChange) {
      this.onAfterChange(this, a);
    }
    this.sendActionToCanvas("onAfterChange", this);
  };
  m.prototype.connectionChange = function(a, b) {
    this.updateExecutionOrder();
    if (this.onConnectionChange) {
      this.onConnectionChange(a);
    }
    this._version++;
    this.sendActionToCanvas("onConnectionChange");
  };
  m.prototype.isLive = function() {
    if (!this.list_of_graphcanvas) {
      return !1;
    }
    for (var a = 0; a < this.list_of_graphcanvas.length; ++a) {
      if (this.list_of_graphcanvas[a].live_mode) {
        return !0;
      }
    }
    return !1;
  };
  m.prototype.clearTriggeredSlots = function() {
    for (var a in this.links) {
      var b = this.links[a];
      b && b._last_time && (b._last_time = 0);
    }
  };
  m.prototype.change = function() {
    g.debug && console.log("Graph changed");
    this.sendActionToCanvas("setDirty", [!0, !0]);
    if (this.on_change) {
      this.on_change(this);
    }
  };
  m.prototype.setDirtyCanvas = function(a, b) {
    this.sendActionToCanvas("setDirty", [a, b]);
  };
  m.prototype.removeLink = function(a) {
    if (a = this.links[a]) {
      var b = this.getNodeById(a.target_id);
      b && b.disconnectInput(a.target_slot);
    }
  };
  m.prototype.serialize = function() {
    for (var a = [], b = 0, c = this._nodes.length; b < c; ++b) {
      a.push(this._nodes[b].serialize());
    }
    c = [];
    for (b in this.links) {
      var e = this.links[b];
      if (!e.serialize) {
        console.warn("weird LLink bug, link info is not a LLink but a regular object");
        var d = new y;
        for (f in e) {
          d[f] = e[f];
        }
        e = this.links[b] = d;
      }
      c.push(e.serialize());
    }
    var f = [];
    for (b = 0; b < this._groups.length; ++b) {
      f.push(this._groups[b].serialize());
    }
    a = {last_node_id:this.last_node_id, last_link_id:this.last_link_id, nodes:a, links:c, groups:f, config:this.config, extra:this.extra, version:g.VERSION};
    if (this.onSerialize) {
      this.onSerialize(a);
    }
    return a;
  };
  m.prototype.configure = function(a, b) {
    if (a) {
      b || this.clear();
      b = a.nodes;
      if (a.links && a.links.constructor === Array) {
        for (var c = [], e = 0; e < a.links.length; ++e) {
          var d = a.links[e];
          if (d) {
            var f = new y;
            f.configure(d);
            c[f.id] = f;
          } else {
            console.warn("serialized graph link data contains errors, skipping.");
          }
        }
        a.links = c;
      }
      for (e in a) {
        "nodes" != e && "groups" != e && (this[e] = a[e]);
      }
      c = !1;
      this._nodes = [];
      if (b) {
        e = 0;
        for (d = b.length; e < d; ++e) {
          f = b[e];
          var h = g.createNode(f.type, f.title);
          h || (g.debug && console.log("Node not found or has errors: " + f.type), h = new l, h.last_serialization = f, c = h.has_errors = !0);
          h.id = f.id;
          this.add(h, !0);
        }
        e = 0;
        for (d = b.length; e < d; ++e) {
          f = b[e], (h = this.getNodeById(f.id)) && h.configure(f);
        }
      }
      this._groups.length = 0;
      if (a.groups) {
        for (e = 0; e < a.groups.length; ++e) {
          b = new g.LGraphGroup, b.configure(a.groups[e]), this.add(b);
        }
      }
      this.updateExecutionOrder();
      this.extra = a.extra || {};
      if (this.onConfigure) {
        this.onConfigure(a);
      }
      this._version++;
      this.setDirtyCanvas(!0, !0);
      return c;
    }
  };
  m.prototype.load = function(a, b) {
    var c = this;
    if (a.constructor === File || a.constructor === Blob) {
      var e = new FileReader;
      e.addEventListener("load", function(a) {
        a = JSON.parse(a.target.result);
        c.configure(a);
        b && b();
      });
      e.readAsText(a);
    } else {
      var d = new XMLHttpRequest;
      d.open("GET", a, !0);
      d.send(null);
      d.onload = function(a) {
        200 !== d.status ? console.error("Error loading graph:", d.status, d.response) : (a = JSON.parse(d.response), c.configure(a), b && b());
      };
      d.onerror = function(a) {
        console.error("Error loading graph:", a);
      };
    }
  };
  m.prototype.onNodeTrace = function(a, b, c) {
  };
  y.prototype.configure = function(a) {
    a.constructor === Array ? (this.id = a[0], this.origin_id = a[1], this.origin_slot = a[2], this.target_id = a[3], this.target_slot = a[4], this.type = a[5]) : (this.id = a.id, this.type = a.type, this.origin_id = a.origin_id, this.origin_slot = a.origin_slot, this.target_id = a.target_id, this.target_slot = a.target_slot);
  };
  y.prototype.serialize = function() {
    return [this.id, this.origin_id, this.origin_slot, this.target_id, this.target_slot, this.type];
  };
  g.LLink = y;
  t.LGraphNode = g.LGraphNode = l;
  l.prototype._ctor = function(a) {
    this.title = a || "Unnamed";
    this.size = [g.NODE_WIDTH, 60];
    this.graph = null;
    this._pos = new Float32Array(10, 10);
    Object.defineProperty(this, "pos", {set:function(a) {
      !a || 2 > a.length || (this._pos[0] = a[0], this._pos[1] = a[1]);
    }, get:function() {
      return this._pos;
    }, enumerable:!0});
    this.id = -1;
    this.type = null;
    this.inputs = [];
    this.outputs = [];
    this.connections = [];
    this.properties = {};
    this.properties_info = [];
    this.flags = {};
  };
  l.prototype.configure = function(a) {
    this.graph && this.graph._version++;
    for (var b in a) {
      if ("properties" == b) {
        for (var c in a.properties) {
          if (this.properties[c] = a.properties[c], this.onPropertyChanged) {
            this.onPropertyChanged(c, a.properties[c]);
          }
        }
      } else {
        null != a[b] && ("object" == typeof a[b] ? this[b] && this[b].configure ? this[b].configure(a[b]) : this[b] = g.cloneObject(a[b], this[b]) : this[b] = a[b]);
      }
    }
    a.title || (this.title = this.constructor.title);
    if (this.inputs) {
      for (c = 0; c < this.inputs.length; ++c) {
        b = this.inputs[c];
        var e = this.graph ? this.graph.links[b.link] : null;
        if (this.onConnectionsChange) {
          this.onConnectionsChange(g.INPUT, c, !0, e, b);
        }
        if (this.onInputAdded) {
          this.onInputAdded(b);
        }
      }
    }
    if (this.outputs) {
      for (c = 0; c < this.outputs.length; ++c) {
        var d = this.outputs[c];
        if (d.links) {
          for (b = 0; b < d.links.length; ++b) {
            if (e = this.graph ? this.graph.links[d.links[b]] : null, this.onConnectionsChange) {
              this.onConnectionsChange(g.OUTPUT, c, !0, e, d);
            }
          }
          if (this.onOutputAdded) {
            this.onOutputAdded(d);
          }
        }
      }
    }
    if (this.widgets) {
      for (c = 0; c < this.widgets.length; ++c) {
        (b = this.widgets[c]) && b.options && b.options.property && this.properties[b.options.property] && (b.value = JSON.parse(JSON.stringify(this.properties[b.options.property])));
      }
      if (a.widgets_values) {
        for (c = 0; c < a.widgets_values.length; ++c) {
          this.widgets[c] && (this.widgets[c].value = a.widgets_values[c]);
        }
      }
    }
    if (this.onConfigure) {
      this.onConfigure(a);
    }
  };
  l.prototype.serialize = function() {
    var a = {id:this.id, type:this.type, pos:this.pos, size:this.size, flags:g.cloneObject(this.flags), order:this.order, mode:this.mode};
    if (this.constructor === l && this.last_serialization) {
      return this.last_serialization;
    }
    this.inputs && (a.inputs = this.inputs);
    if (this.outputs) {
      for (var b = 0; b < this.outputs.length; b++) {
        delete this.outputs[b]._data;
      }
      a.outputs = this.outputs;
    }
    this.title && this.title != this.constructor.title && (a.title = this.title);
    this.properties && (a.properties = g.cloneObject(this.properties));
    if (this.widgets && this.serialize_widgets) {
      for (a.widgets_values = [], b = 0; b < this.widgets.length; ++b) {
        a.widgets_values[b] = this.widgets[b] ? this.widgets[b].value : null;
      }
    }
    a.type || (a.type = this.constructor.type);
    this.color && (a.color = this.color);
    this.bgcolor && (a.bgcolor = this.bgcolor);
    this.boxcolor && (a.boxcolor = this.boxcolor);
    this.shape && (a.shape = this.shape);
    this.onSerialize && this.onSerialize(a) && console.warn("node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter");
    return a;
  };
  l.prototype.clone = function() {
    var a = g.createNode(this.type);
    if (!a) {
      return null;
    }
    var b = g.cloneObject(this.serialize());
    if (b.inputs) {
      for (var c = 0; c < b.inputs.length; ++c) {
        b.inputs[c].link = null;
      }
    }
    if (b.outputs) {
      for (c = 0; c < b.outputs.length; ++c) {
        b.outputs[c].links && (b.outputs[c].links.length = 0);
      }
    }
    delete b.id;
    a.configure(b);
    return a;
  };
  l.prototype.toString = function() {
    return JSON.stringify(this.serialize());
  };
  l.prototype.getTitle = function() {
    return this.title || this.constructor.title;
  };
  l.prototype.setProperty = function(a, b) {
    this.properties || (this.properties = {});
    if (b !== this.properties[a]) {
      var c = this.properties[a];
      this.properties[a] = b;
      this.onPropertyChanged && !1 === this.onPropertyChanged(a, b, c) && (this.properties[a] = c);
      if (this.widgets) {
        for (c = 0; c < this.widgets.length; ++c) {
          var e = this.widgets[c];
          if (e && e.options.property == a) {
            e.value = b;
            break;
          }
        }
      }
    }
  };
  l.prototype.setOutputData = function(a, b) {
    if (this.outputs && !(-1 == a || a >= this.outputs.length)) {
      var c = this.outputs[a];
      if (c && (c._data = b, this.outputs[a].links)) {
        for (c = 0; c < this.outputs[a].links.length; c++) {
          var e = this.graph.links[this.outputs[a].links[c]];
          e && (e.data = b);
        }
      }
    }
  };
  l.prototype.setOutputDataType = function(a, b) {
    if (this.outputs && !(-1 == a || a >= this.outputs.length)) {
      var c = this.outputs[a];
      if (c && (c.type = b, this.outputs[a].links)) {
        for (c = 0; c < this.outputs[a].links.length; c++) {
          this.graph.links[this.outputs[a].links[c]].type = b;
        }
      }
    }
  };
  l.prototype.getInputData = function(a, b) {
    if (this.inputs && !(a >= this.inputs.length || null == this.inputs[a].link)) {
      a = this.graph.links[this.inputs[a].link];
      if (!a) {
        return null;
      }
      if (!b) {
        return a.data;
      }
      b = this.graph.getNodeById(a.origin_id);
      if (!b) {
        return a.data;
      }
      if (b.updateOutputData) {
        b.updateOutputData(a.origin_slot);
      } else {
        if (b.onExecute) {
          b.onExecute();
        }
      }
      return a.data;
    }
  };
  l.prototype.getInputDataType = function(a) {
    if (!this.inputs || a >= this.inputs.length || null == this.inputs[a].link) {
      return null;
    }
    a = this.graph.links[this.inputs[a].link];
    if (!a) {
      return null;
    }
    var b = this.graph.getNodeById(a.origin_id);
    return b ? (a = b.outputs[a.origin_slot]) ? a.type : null : a.type;
  };
  l.prototype.getInputDataByName = function(a, b) {
    a = this.findInputSlot(a);
    return -1 == a ? null : this.getInputData(a, b);
  };
  l.prototype.isInputConnected = function(a) {
    return this.inputs ? a < this.inputs.length && null != this.inputs[a].link : !1;
  };
  l.prototype.getInputInfo = function(a) {
    return this.inputs ? a < this.inputs.length ? this.inputs[a] : null : null;
  };
  l.prototype.getInputLink = function(a) {
    return this.inputs ? a < this.inputs.length ? this.graph.links[this.inputs[a].link] : null : null;
  };
  l.prototype.getInputNode = function(a) {
    if (!this.inputs || a >= this.inputs.length) {
      return null;
    }
    a = this.inputs[a];
    return a && null !== a.link ? (a = this.graph.links[a.link]) ? this.graph.getNodeById(a.origin_id) : null : null;
  };
  l.prototype.getInputOrProperty = function(a) {
    if (!this.inputs || !this.inputs.length) {
      return this.properties ? this.properties[a] : null;
    }
    for (var b = 0, c = this.inputs.length; b < c; ++b) {
      var e = this.inputs[b];
      if (a == e.name && null != e.link && (e = this.graph.links[e.link])) {
        return e.data;
      }
    }
    return this.properties[a];
  };
  l.prototype.getOutputData = function(a) {
    return !this.outputs || a >= this.outputs.length ? null : this.outputs[a]._data;
  };
  l.prototype.getOutputInfo = function(a) {
    return this.outputs ? a < this.outputs.length ? this.outputs[a] : null : null;
  };
  l.prototype.isOutputConnected = function(a) {
    return this.outputs ? a < this.outputs.length && this.outputs[a].links && this.outputs[a].links.length : !1;
  };
  l.prototype.isAnyOutputConnected = function() {
    if (!this.outputs) {
      return !1;
    }
    for (var a = 0; a < this.outputs.length; ++a) {
      if (this.outputs[a].links && this.outputs[a].links.length) {
        return !0;
      }
    }
    return !1;
  };
  l.prototype.getOutputNodes = function(a) {
    if (!this.outputs || 0 == this.outputs.length || a >= this.outputs.length) {
      return null;
    }
    a = this.outputs[a];
    if (!a.links || 0 == a.links.length) {
      return null;
    }
    for (var b = [], c = 0; c < a.links.length; c++) {
      var e = this.graph.links[a.links[c]];
      e && (e = this.graph.getNodeById(e.target_id)) && b.push(e);
    }
    return b;
  };
  l.prototype.addOnTriggerInput = function() {
    var a = this.findInputSlot("onTrigger");
    return -1 == a ? (this.addInput("onTrigger", g.EVENT, {optional:!0, nameLocked:!0}), this.findInputSlot("onTrigger")) : a;
  };
  l.prototype.addOnExecutedOutput = function() {
    var a = this.findOutputSlot("onExecuted");
    return -1 == a ? (this.addOutput("onExecuted", g.ACTION, {optional:!0, nameLocked:!0}), this.findOutputSlot("onExecuted")) : a;
  };
  l.prototype.onAfterExecuteNode = function(a, b) {
    var c = this.findOutputSlot("onExecuted");
    -1 != c && this.triggerSlot(c, a, null, b);
  };
  l.prototype.changeMode = function(a) {
    switch(a) {
      case g.ON_EVENT:
        break;
      case g.ON_TRIGGER:
        this.addOnTriggerInput();
        this.addOnExecutedOutput();
        break;
      case g.NEVER:
        break;
      case g.ALWAYS:
        break;
      case g.ON_REQUEST:
        break;
      default:
        return !1;
    }
    this.mode = a;
    return !0;
  };
  l.prototype.doExecute = function(a, b) {
    b = b || {};
    this.onExecute && (b.action_call || (b.action_call = this.id + "_exec_" + Math.floor(9999 * Math.random())), this.graph.nodes_executing[this.id] = !0, this.onExecute(a, b), this.graph.nodes_executing[this.id] = !1, this.exec_version = this.graph.iteration, b && b.action_call && (this.action_call = b.action_call, this.graph.nodes_executedAction[this.id] = b.action_call));
    this.execute_triggered = 2;
    if (this.onAfterExecuteNode) {
      this.onAfterExecuteNode(a, b);
    }
  };
  l.prototype.actionDo = function(a, b, c) {
    c = c || {};
    this.onAction && (c.action_call || (c.action_call = this.id + "_" + (a ? a : "action") + "_" + Math.floor(9999 * Math.random())), this.graph.nodes_actioning[this.id] = a ? a : "actioning", this.onAction(a, b, c), this.graph.nodes_actioning[this.id] = !1, c && c.action_call && (this.action_call = c.action_call, this.graph.nodes_executedAction[this.id] = c.action_call));
    this.action_triggered = 2;
    if (this.onAfterExecuteNode) {
      this.onAfterExecuteNode(b, c);
    }
  };
  l.prototype.trigger = function(a, b, c) {
    if (this.outputs && this.outputs.length) {
      this.graph && (this.graph._last_trigger_time = g.getTime());
      for (var e = 0; e < this.outputs.length; ++e) {
        var d = this.outputs[e];
        !d || d.type !== g.EVENT || a && d.name != a || this.triggerSlot(e, b, null, c);
      }
    }
  };
  l.prototype.triggerSlot = function(a, b, c, e) {
    e = e || {};
    if (this.outputs && (a = this.outputs[a]) && (a = a.links) && a.length) {
      this.graph && (this.graph._last_trigger_time = g.getTime());
      for (var d = 0; d < a.length; ++d) {
        var f = a[d];
        if (null == c || c == f) {
          var h = this.graph.links[a[d]];
          h && (h._last_time = g.getTime(), f = this.graph.getNodeById(h.target_id)) && (f.mode === g.ON_TRIGGER ? (e.action_call || (e.action_call = this.id + "_trigg_" + Math.floor(9999 * Math.random())), f.onExecute && f.doExecute(b, e)) : f.onAction && (e.action_call || (e.action_call = this.id + "_act_" + Math.floor(9999 * Math.random())), h = f.inputs[h.target_slot], f.actionDo(h.name, b, e)));
        }
      }
    }
  };
  l.prototype.clearTriggeredSlot = function(a, b) {
    if (this.outputs && (a = this.outputs[a]) && (a = a.links) && a.length) {
      for (var c = 0; c < a.length; ++c) {
        var e = a[c];
        if (null == b || b == e) {
          if (e = this.graph.links[a[c]]) {
            e._last_time = 0;
          }
        }
      }
    }
  };
  l.prototype.setSize = function(a) {
    this.size = a;
    if (this.onResize) {
      this.onResize(this.size);
    }
  };
  l.prototype.addProperty = function(a, b, c, e) {
    c = {name:a, type:c, default_value:b};
    if (e) {
      for (var d in e) {
        c[d] = e[d];
      }
    }
    this.properties_info || (this.properties_info = []);
    this.properties_info.push(c);
    this.properties || (this.properties = {});
    this.properties[a] = b;
    return c;
  };
  l.prototype.addOutput = function(a, b, c) {
    a = {name:a, type:b, links:null};
    if (c) {
      for (var e in c) {
        a[e] = c[e];
      }
    }
    this.outputs || (this.outputs = []);
    this.outputs.push(a);
    if (this.onOutputAdded) {
      this.onOutputAdded(a);
    }
    g.auto_load_slot_types && g.registerNodeAndSlotType(this, b, !0);
    this.setSize(this.computeSize());
    this.setDirtyCanvas(!0, !0);
    return a;
  };
  l.prototype.addOutputs = function(a) {
    for (var b = 0; b < a.length; ++b) {
      var c = a[b], e = {name:c[0], type:c[1], link:null};
      if (a[2]) {
        for (var d in c[2]) {
          e[d] = c[2][d];
        }
      }
      this.outputs || (this.outputs = []);
      this.outputs.push(e);
      if (this.onOutputAdded) {
        this.onOutputAdded(e);
      }
      g.auto_load_slot_types && g.registerNodeAndSlotType(this, c[1], !0);
    }
    this.setSize(this.computeSize());
    this.setDirtyCanvas(!0, !0);
  };
  l.prototype.removeOutput = function(a) {
    this.disconnectOutput(a);
    this.outputs.splice(a, 1);
    for (var b = a; b < this.outputs.length; ++b) {
      if (this.outputs[b] && this.outputs[b].links) {
        for (var c = this.outputs[b].links, e = 0; e < c.length; ++e) {
          var d = this.graph.links[c[e]];
          d && --d.origin_slot;
        }
      }
    }
    this.setSize(this.computeSize());
    if (this.onOutputRemoved) {
      this.onOutputRemoved(a);
    }
    this.setDirtyCanvas(!0, !0);
  };
  l.prototype.addInput = function(a, b, c) {
    b = b || 0;
    a = {name:a, type:b, link:null};
    if (c) {
      for (var e in c) {
        a[e] = c[e];
      }
    }
    this.inputs || (this.inputs = []);
    this.inputs.push(a);
    this.setSize(this.computeSize());
    if (this.onInputAdded) {
      this.onInputAdded(a);
    }
    g.registerNodeAndSlotType(this, b);
    this.setDirtyCanvas(!0, !0);
    return a;
  };
  l.prototype.addInputs = function(a) {
    for (var b = 0; b < a.length; ++b) {
      var c = a[b], e = {name:c[0], type:c[1], link:null};
      if (a[2]) {
        for (var d in c[2]) {
          e[d] = c[2][d];
        }
      }
      this.inputs || (this.inputs = []);
      this.inputs.push(e);
      if (this.onInputAdded) {
        this.onInputAdded(e);
      }
      g.registerNodeAndSlotType(this, c[1]);
    }
    this.setSize(this.computeSize());
    this.setDirtyCanvas(!0, !0);
  };
  l.prototype.removeInput = function(a) {
    this.disconnectInput(a);
    for (var b = this.inputs.splice(a, 1), c = a; c < this.inputs.length; ++c) {
      if (this.inputs[c]) {
        var e = this.graph.links[this.inputs[c].link];
        e && --e.target_slot;
      }
    }
    this.setSize(this.computeSize());
    if (this.onInputRemoved) {
      this.onInputRemoved(a, b[0]);
    }
    this.setDirtyCanvas(!0, !0);
  };
  l.prototype.addConnection = function(a, b, c, e) {
    a = {name:a, type:b, pos:c, direction:e, links:null};
    this.connections.push(a);
    return a;
  };
  l.prototype.computeSize = function(a) {
    function b(a) {
      return a ? f * a.length * 0.6 : 0;
    }
    if (this.constructor.size) {
      return this.constructor.size.concat();
    }
    var c = this.inputs ? this.inputs.filter(function(a) {
      return g.draw_invisible_connections || !1 !== a.visible;
    }) : null, e = this.outputs ? this.outputs.filter(function(a) {
      return g.draw_invisible_connections || !1 !== a.visible;
    }) : null, d = Math.max(c ? c.length : 1, this.outputs ? this.outputs.length : 1);
    a = a || new Float32Array([0, 0]);
    d = Math.max(d, 1);
    var f = g.NODE_TEXT_SIZE, h = b(this.title), k = 0, q = 0;
    if (c) {
      for (var r = 0, u = c.length; r < u; ++r) {
        var p = c[r];
        p = p.label || p.name || "";
        p = b(p);
        k < p && (k = p);
      }
    }
    if (e) {
      for (r = 0, u = e.length; r < u; ++r) {
        c = e[r], p = c.label || c.name || "", p = b(p), q < p && (q = p);
      }
    }
    a[0] = Math.max(k + q + 10, h);
    a[0] = Math.max(a[0], g.NODE_WIDTH);
    this.widgets && this.widgets.length && (a[0] = Math.max(a[0], 1.5 * g.NODE_WIDTH));
    a[1] = (this.constructor.slot_start_y || 0) + d * g.NODE_SLOT_HEIGHT;
    e = 0;
    if (this.widgets && this.widgets.length) {
      r = 0;
      for (u = this.widgets.length; r < u; ++r) {
        e = this.widgets[r].computeSize ? e + (this.widgets[r].computeSize(a[0])[1] + 4) : e + (g.NODE_WIDGET_HEIGHT + 4);
      }
      e += 8;
    }
    a[1] = this.widgets_up ? Math.max(a[1], e) : null != this.widgets_start_y ? Math.max(a[1], e + this.widgets_start_y) : a[1] + e;
    this.constructor.min_height && a[1] < this.constructor.min_height && (a[1] = this.constructor.min_height);
    a[1] += 6;
    return a;
  };
  l.prototype.getPropertyInfo = function(a) {
    var b = null;
    if (this.properties_info) {
      for (var c = 0; c < this.properties_info.length; ++c) {
        if (this.properties_info[c].name == a) {
          b = this.properties_info[c];
          break;
        }
      }
    }
    this.constructor["@" + a] && (b = this.constructor["@" + a]);
    this.constructor.widgets_info && this.constructor.widgets_info[a] && (b = this.constructor.widgets_info[a]);
    !b && this.onGetPropertyInfo && (b = this.onGetPropertyInfo(a));
    b || (b = {});
    b.type || (b.type = typeof this.properties[a]);
    "combo" == b.widget && (b.type = "enum");
    return b;
  };
  l.prototype.addWidget = function(a, b, c, e, d) {
    this.widgets || (this.widgets = []);
    !d && e && e.constructor === Object && (d = e, e = null);
    d && d.constructor === String && (d = {property:d});
    e && e.constructor === String && (d || (d = {}), d.property = e, e = null);
    e && e.constructor !== Function && (console.warn("addWidget: callback must be a function"), e = null);
    b = {type:a.toLowerCase(), name:b, value:c, callback:e, options:d || {}};
    void 0 !== b.options.y && (b.y = b.options.y);
    e || b.options.callback || b.options.property || console.warn("LiteGraph addWidget(...) without a callback or property assigned");
    if ("combo" == a && !b.options.values) {
      throw "LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }";
    }
    this.widgets.push(b);
    this.setSize(this.computeSize());
    return b;
  };
  l.prototype.addCustomWidget = function(a) {
    this.widgets || (this.widgets = []);
    this.widgets.push(a);
    return a;
  };
  l.prototype.getBounding = function(a) {
    a = a || new Float32Array(4);
    a[0] = this.pos[0] - 4;
    a[1] = this.pos[1] - g.NODE_TITLE_HEIGHT;
    a[2] = this.size[0] + 4;
    a[3] = this.flags.collapsed ? g.NODE_TITLE_HEIGHT : this.size[1] + g.NODE_TITLE_HEIGHT;
    if (this.onBounding) {
      this.onBounding(a);
    }
    return a;
  };
  l.prototype.isPointInside = function(a, b, c, e) {
    c = c || 0;
    var d = this.graph && this.graph.isLive() ? 0 : g.NODE_TITLE_HEIGHT;
    e && (d = 0);
    if (this.flags && this.flags.collapsed) {
      if (B(a, b, this.pos[0] - c, this.pos[1] - g.NODE_TITLE_HEIGHT - c, (this._collapsed_width || g.NODE_COLLAPSED_WIDTH) + 2 * c, g.NODE_TITLE_HEIGHT + 2 * c)) {
        return !0;
      }
    } else {
      if (this.pos[0] - 4 - c < a && this.pos[0] + this.size[0] + 4 + c > a && this.pos[1] - d - c < b && this.pos[1] + this.size[1] + c > b) {
        return !0;
      }
    }
    return !1;
  };
  l.prototype.getSlotInPosition = function(a, b) {
    var c = new Float32Array(2);
    if (this.inputs) {
      for (var e = 0, d = this.inputs.length; e < d; ++e) {
        var f = this.inputs[e];
        this.getConnectionPos(!0, e, c);
        if (B(a, b, c[0] - 10, c[1] - 5, 20, 10)) {
          return {input:f, slot:e, link_pos:c};
        }
      }
    }
    if (this.outputs) {
      for (e = 0, d = this.outputs.length; e < d; ++e) {
        if (f = this.outputs[e], this.getConnectionPos(!1, e, c), B(a, b, c[0] - 10, c[1] - 5, 20, 10)) {
          return {output:f, slot:e, link_pos:c};
        }
      }
    }
    return null;
  };
  l.prototype.findInputSlot = function(a, b) {
    if (!this.inputs) {
      return -1;
    }
    for (var c = 0, e = this.inputs.length; c < e; ++c) {
      if (a == this.inputs[c].name) {
        return b ? this.inputs[c] : c;
      }
    }
    return -1;
  };
  l.prototype.findOutputSlot = function(a, b) {
    b = b || !1;
    if (!this.outputs) {
      return -1;
    }
    for (var c = 0, e = this.outputs.length; c < e; ++c) {
      if (a == this.outputs[c].name) {
        return b ? this.outputs[c] : c;
      }
    }
    return -1;
  };
  l.prototype.findInputSlotFree = function(a) {
    a = a || {};
    a = Object.assign({returnObj:!1, typesNotAccepted:[]}, a);
    if (!this.inputs) {
      return -1;
    }
    for (var b = 0, c = this.inputs.length; b < c; ++b) {
      if (!(this.inputs[b].link && null != this.inputs[b].link || a.typesNotAccepted && a.typesNotAccepted.includes && a.typesNotAccepted.includes(this.inputs[b].type))) {
        return a.returnObj ? this.inputs[b] : b;
      }
    }
    return -1;
  };
  l.prototype.findOutputSlotFree = function(a) {
    a = a || {};
    a = Object.assign({returnObj:!1, typesNotAccepted:[]}, a);
    if (!this.outputs) {
      return -1;
    }
    for (var b = 0, c = this.outputs.length; b < c; ++b) {
      if (!(this.outputs[b].links && null != this.outputs[b].links || a.typesNotAccepted && a.typesNotAccepted.includes && a.typesNotAccepted.includes(this.outputs[b].type))) {
        return a.returnObj ? this.outputs[b] : b;
      }
    }
    return -1;
  };
  l.prototype.findInputSlotByType = function(a, b, c, e) {
    return this.findSlotByType(!0, a, b, c, e);
  };
  l.prototype.findOutputSlotByType = function(a, b, c, e) {
    return this.findSlotByType(!1, a, b, c, e);
  };
  l.prototype.findSlotByType = function(a, b, c, e, d) {
    c = c || !1;
    e = e || !1;
    d = d || !1;
    a = a ? this.inputs : this.outputs;
    if (!a) {
      return -1;
    }
    if ("" == b || "*" == b) {
      b = 0;
    }
    for (var f = 0, h = a.length; f < h; ++f) {
      var k = (b + "").toLowerCase().split(","), q = "0" == a[f].type || "*" == a[f].type ? "0" : a[f].type;
      q = (q + "").toLowerCase().split(",");
      for (sI = 0; sI < k.length; sI++) {
        for (dI = 0; dI < q.length; dI++) {
          if ("_event_" == k[sI] && (k[sI] = g.EVENT), "_event_" == q[sI] && (q[sI] = g.EVENT), "*" == k[sI] && (k[sI] = 0), "*" == q[sI] && (q[sI] = 0), !(k[sI] != q[dI] || e && a[f].links && null !== a[f].links)) {
            return c ? a[f] : f;
          }
        }
      }
    }
    if (e && !d) {
      for (f = 0, h = a.length; f < h; ++f) {
        for (k = (b + "").toLowerCase().split(","), q = "0" == a[f].type || "*" == a[f].type ? "0" : a[f].type, q = (q + "").toLowerCase().split(","), sI = 0; sI < k.length; sI++) {
          for (dI = 0; dI < q.length; dI++) {
            if ("*" == k[sI] && (k[sI] = 0), "*" == q[sI] && (q[sI] = 0), k[sI] == q[dI]) {
              return c ? a[f] : f;
            }
          }
        }
      }
    }
    return -1;
  };
  l.prototype.connectByType = function(a, b, c, e) {
    e = e || {};
    e = Object.assign({createEventInCase:!0, firstFreeIfOutputGeneralInCase:!0, generalTypeInCase:!0}, e);
    b && b.constructor === Number && (b = this.graph.getNodeById(b));
    d = b.findInputSlotByType(c, !1, !0);
    if (0 <= d && null !== d) {
      return this.connect(a, b, d);
    }
    if (e.createEventInCase && c == g.EVENT) {
      return this.connect(a, b, -1);
    }
    if (e.generalTypeInCase) {
      var d = b.findInputSlotByType(0, !1, !0, !0);
      if (0 <= d) {
        return this.connect(a, b, d);
      }
    }
    if (e.firstFreeIfOutputGeneralInCase && (0 == c || "*" == c || "" == c) && (d = b.findInputSlotFree({typesNotAccepted:[g.EVENT]}), 0 <= d)) {
      return this.connect(a, b, d);
    }
    console.debug("no way to connect type: ", c, " to targetNODE ", b);
    return null;
  };
  l.prototype.connectByTypeOutput = function(a, b, c, e) {
    e = e || {};
    e = Object.assign({createEventInCase:!0, firstFreeIfInputGeneralInCase:!0, generalTypeInCase:!0}, e);
    b && b.constructor === Number && (b = this.graph.getNodeById(b));
    d = b.findOutputSlotByType(c, !1, !0);
    if (0 <= d && null !== d) {
      return b.connect(d, this, a);
    }
    if (e.generalTypeInCase) {
      var d = b.findOutputSlotByType(0, !1, !0, !0);
      if (0 <= d) {
        return b.connect(d, this, a);
      }
    }
    if (e.createEventInCase && c == g.EVENT && g.do_add_triggers_slots) {
      return d = b.addOnExecutedOutput(), b.connect(d, this, a);
    }
    if (e.firstFreeIfInputGeneralInCase && (0 == c || "*" == c || "" == c) && (d = b.findOutputSlotFree({typesNotAccepted:[g.EVENT]}), 0 <= d)) {
      return b.connect(d, this, a);
    }
    console.debug("no way to connect byOUT type: ", c, " to sourceNODE ", b);
    return null;
  };
  l.prototype.connect = function(a, b, c) {
    c = c || 0;
    if (!this.graph) {
      return console.log("Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them."), null;
    }
    if (a.constructor === String) {
      if (a = this.findOutputSlot(a), -1 == a) {
        return g.debug && console.log("Connect: Error, no slot of name " + a), null;
      }
    } else {
      if (!this.outputs || a >= this.outputs.length) {
        return g.debug && console.log("Connect: Error, slot number not found"), null;
      }
    }
    b && b.constructor === Number && (b = this.graph.getNodeById(b));
    if (!b) {
      throw "target node is null";
    }
    if (b == this) {
      return null;
    }
    if (c.constructor === String) {
      if (c = b.findInputSlot(c), -1 == c) {
        return g.debug && console.log("Connect: Error, no slot of name " + c), null;
      }
    } else {
      if (c === g.EVENT) {
        if (g.do_add_triggers_slots) {
          b.changeMode(g.ON_TRIGGER), c = b.findInputSlot("onTrigger");
        } else {
          return null;
        }
      } else {
        if (!b.inputs || c >= b.inputs.length) {
          return g.debug && console.log("Connect: Error, slot number not found"), null;
        }
      }
    }
    var e = b.inputs[c], d = this.outputs[a];
    if (!this.outputs[a]) {
      return null;
    }
    b.onBeforeConnectInput && (c = b.onBeforeConnectInput(c));
    if (!1 === c || null === c || !g.isValidConnection(d.type, e.type)) {
      return this.setDirtyCanvas(!1, !0), null;
    }
    if (b.onConnectInput && !1 === b.onConnectInput(c, d.type, d, this, a) || this.onConnectOutput && !1 === this.onConnectOutput(a, e.type, e, b, c)) {
      return null;
    }
    b.inputs[c] && null != b.inputs[c].link && (this.graph.beforeChange(), b.disconnectInput(c, {doProcessChange:!1}));
    if (null !== d.links && d.links.length) {
      switch(d.type) {
        case g.EVENT:
          g.allow_multi_output_for_events || (this.graph.beforeChange(), this.disconnectOutput(a, !1, {doProcessChange:!1}));
      }
    }
    var f = new y(++this.graph.last_link_id, e.type || d.type, this.id, a, b.id, c);
    this.graph.links[f.id] = f;
    null == d.links && (d.links = []);
    d.links.push(f.id);
    b.inputs[c].link = f.id;
    this.graph && this.graph._version++;
    if (this.onConnectionsChange) {
      this.onConnectionsChange(g.OUTPUT, a, !0, f, d);
    }
    if (b.onConnectionsChange) {
      b.onConnectionsChange(g.INPUT, c, !0, f, e);
    }
    this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(g.INPUT, b, c, this, a), this.graph.onNodeConnectionChange(g.OUTPUT, this, a, b, c));
    this.setDirtyCanvas(!1, !0);
    this.graph.afterChange();
    this.graph.connectionChange(this, f);
    return f;
  };
  l.prototype.disconnectOutput = function(a, b) {
    if (a.constructor === String) {
      if (a = this.findOutputSlot(a), -1 == a) {
        return g.debug && console.log("Connect: Error, no slot of name " + a), !1;
      }
    } else {
      if (!this.outputs || a >= this.outputs.length) {
        return g.debug && console.log("Connect: Error, slot number not found"), !1;
      }
    }
    var c = this.outputs[a];
    if (!c || !c.links || 0 == c.links.length) {
      return !1;
    }
    if (b) {
      b.constructor === Number && (b = this.graph.getNodeById(b));
      if (!b) {
        throw "Target Node not found";
      }
      for (var e = 0, d = c.links.length; e < d; e++) {
        var f = c.links[e], h = this.graph.links[f];
        if (h.target_id == b.id) {
          c.links.splice(e, 1);
          var k = b.inputs[h.target_slot];
          k.link = null;
          delete this.graph.links[f];
          this.graph && this.graph._version++;
          if (b.onConnectionsChange) {
            b.onConnectionsChange(g.INPUT, h.target_slot, !1, h, k);
          }
          if (this.onConnectionsChange) {
            this.onConnectionsChange(g.OUTPUT, a, !1, h, c);
          }
          if (this.graph && this.graph.onNodeConnectionChange) {
            this.graph.onNodeConnectionChange(g.OUTPUT, this, a);
          }
          this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(g.OUTPUT, this, a), this.graph.onNodeConnectionChange(g.INPUT, b, h.target_slot));
          break;
        }
      }
    } else {
      e = 0;
      for (d = c.links.length; e < d; e++) {
        if (f = c.links[e], h = this.graph.links[f]) {
          b = this.graph.getNodeById(h.target_id);
          this.graph && this.graph._version++;
          if (b) {
            k = b.inputs[h.target_slot];
            k.link = null;
            if (b.onConnectionsChange) {
              b.onConnectionsChange(g.INPUT, h.target_slot, !1, h, k);
            }
            if (this.graph && this.graph.onNodeConnectionChange) {
              this.graph.onNodeConnectionChange(g.INPUT, b, h.target_slot);
            }
          }
          delete this.graph.links[f];
          if (this.onConnectionsChange) {
            this.onConnectionsChange(g.OUTPUT, a, !1, h, c);
          }
          this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(g.OUTPUT, this, a), this.graph.onNodeConnectionChange(g.INPUT, b, h.target_slot));
        }
      }
      c.links = null;
    }
    this.setDirtyCanvas(!1, !0);
    this.graph.connectionChange(this);
    return !0;
  };
  l.prototype.disconnectInput = function(a) {
    if (a.constructor === String) {
      if (a = this.findInputSlot(a), -1 == a) {
        return g.debug && console.log("Connect: Error, no slot of name " + a), !1;
      }
    } else {
      if (!this.inputs || a >= this.inputs.length) {
        return g.debug && console.log("Connect: Error, slot number not found"), !1;
      }
    }
    var b = this.inputs[a];
    if (!b) {
      return !1;
    }
    var c = this.inputs[a].link;
    if (null != c) {
      this.inputs[a].link = null;
      var e = this.graph.links[c];
      if (e) {
        var d = this.graph.getNodeById(e.origin_id);
        if (!d) {
          return !1;
        }
        var f = d.outputs[e.origin_slot];
        if (!f || !f.links || 0 == f.links.length) {
          return !1;
        }
        for (var h = 0, k = f.links.length; h < k; h++) {
          if (f.links[h] == c) {
            f.links.splice(h, 1);
            break;
          }
        }
        delete this.graph.links[c];
        this.graph && this.graph._version++;
        if (this.onConnectionsChange) {
          this.onConnectionsChange(g.INPUT, a, !1, e, b);
        }
        if (d.onConnectionsChange) {
          d.onConnectionsChange(g.OUTPUT, h, !1, e, f);
        }
        this.graph && this.graph.onNodeConnectionChange && (this.graph.onNodeConnectionChange(g.OUTPUT, d, h), this.graph.onNodeConnectionChange(g.INPUT, this, a));
      }
    }
    this.setDirtyCanvas(!1, !0);
    this.graph && this.graph.connectionChange(this);
    return !0;
  };
  l.prototype.getConnectionPos = function(a, b, c) {
    c = c || new Float32Array(2);
    var e = 0;
    a && this.inputs && (e = this.inputs.length);
    !a && this.outputs && (e = this.outputs.length);
    var d = 0.5 * g.NODE_SLOT_HEIGHT;
    if (this.flags.collapsed) {
      return b = this._collapsed_width || g.NODE_COLLAPSED_WIDTH, this.horizontal ? (c[0] = this.pos[0] + 0.5 * b, c[1] = a ? this.pos[1] - g.NODE_TITLE_HEIGHT : this.pos[1]) : (c[0] = a ? this.pos[0] : this.pos[0] + b, c[1] = this.pos[1] - 0.5 * g.NODE_TITLE_HEIGHT), c;
    }
    if (a && -1 == b) {
      return c[0] = this.pos[0] + 0.5 * g.NODE_TITLE_HEIGHT, c[1] = this.pos[1] + 0.5 * g.NODE_TITLE_HEIGHT, c;
    }
    if (a && e > b && this.inputs[b].pos) {
      return c[0] = this.pos[0] + this.inputs[b].pos[0], c[1] = this.pos[1] + this.inputs[b].pos[1], c;
    }
    if (!a && e > b && this.outputs[b].pos) {
      return c[0] = this.pos[0] + this.outputs[b].pos[0], c[1] = this.pos[1] + this.outputs[b].pos[1], c;
    }
    if (this.horizontal) {
      return c[0] = this.pos[0] + this.size[0] / e * (b + 0.5), c[1] = a ? this.pos[1] - g.NODE_TITLE_HEIGHT : this.pos[1] + this.size[1], c;
    }
    c[0] = a ? this.pos[0] + d : this.pos[0] + this.size[0] + 1 - d;
    c[1] = this.pos[1] + (b + 0.7) * g.NODE_SLOT_HEIGHT + (this.constructor.slot_start_y || 0);
    return c;
  };
  l.prototype.alignToGrid = function() {
    this.pos[0] = g.CANVAS_GRID_SIZE * Math.round(this.pos[0] / g.CANVAS_GRID_SIZE);
    this.pos[1] = g.CANVAS_GRID_SIZE * Math.round(this.pos[1] / g.CANVAS_GRID_SIZE);
  };
  l.prototype.trace = function(a) {
    this.console || (this.console = []);
    this.console.push(a);
    this.console.length > l.MAX_CONSOLE && this.console.shift();
    if (this.graph.onNodeTrace) {
      this.graph.onNodeTrace(this, a);
    }
  };
  l.prototype.setDirtyCanvas = function(a, b) {
    this.graph && this.graph.sendActionToCanvas("setDirty", [a, b]);
  };
  l.prototype.loadImage = function(a) {
    var b = new Image;
    b.src = g.node_images_path + a;
    b.ready = !1;
    var c = this;
    b.onload = function() {
      this.ready = !0;
      c.setDirtyCanvas(!0);
    };
    return b;
  };
  l.prototype.captureInput = function(a) {
    if (this.graph && this.graph.list_of_graphcanvas) {
      for (var b = this.graph.list_of_graphcanvas, c = 0; c < b.length; ++c) {
        var e = b[c];
        if (a || e.node_capturing_input == this) {
          e.node_capturing_input = a ? this : null;
        }
      }
    }
  };
  l.prototype.collapse = function(a) {
    this.graph._version++;
    if (!1 !== this.constructor.collapsable || a) {
      this.flags.collapsed = this.flags.collapsed ? !1 : !0, this.setDirtyCanvas(!0, !0);
    }
  };
  l.prototype.pin = function(a) {
    this.graph._version++;
    this.flags.pinned = void 0 === a ? !this.flags.pinned : a;
  };
  l.prototype.localToScreen = function(a, b, c) {
    return [(a + this.pos[0]) * c.scale + c.offset[0], (b + this.pos[1]) * c.scale + c.offset[1]];
  };
  t.LGraphGroup = g.LGraphGroup = x;
  x.prototype._ctor = function(a) {
    this.title = a || "Group";
    this.font_size = 24;
    this.color = n.node_colors.pale_blue ? n.node_colors.pale_blue.groupcolor : "#AAA";
    this._bounding = new Float32Array([10, 10, 140, 80]);
    this._pos = this._bounding.subarray(0, 2);
    this._size = this._bounding.subarray(2, 4);
    this._nodes = [];
    this.graph = null;
    Object.defineProperty(this, "pos", {set:function(a) {
      !a || 2 > a.length || (this._pos[0] = a[0], this._pos[1] = a[1]);
    }, get:function() {
      return this._pos;
    }, enumerable:!0});
    Object.defineProperty(this, "size", {set:function(a) {
      !a || 2 > a.length || (this._size[0] = Math.max(140, a[0]), this._size[1] = Math.max(80, a[1]));
    }, get:function() {
      return this._size;
    }, enumerable:!0});
  };
  x.prototype.configure = function(a) {
    this.title = a.title;
    this._bounding.set(a.bounding);
    this.color = a.color;
    this.font = a.font;
  };
  x.prototype.serialize = function() {
    var a = this._bounding;
    return {title:this.title, bounding:[Math.round(a[0]), Math.round(a[1]), Math.round(a[2]), Math.round(a[3])], color:this.color, font:this.font};
  };
  x.prototype.move = function(a, b, c) {
    this._pos[0] += a;
    this._pos[1] += b;
    if (!c) {
      for (c = 0; c < this._nodes.length; ++c) {
        var e = this._nodes[c];
        e.pos[0] += a;
        e.pos[1] += b;
      }
    }
  };
  x.prototype.recomputeInsideNodes = function() {
    this._nodes.length = 0;
    for (var a = this.graph._nodes, b = new Float32Array(4), c = 0; c < a.length; ++c) {
      var e = a[c];
      e.getBounding(b);
      H(this._bounding, b) && this._nodes.push(e);
    }
  };
  x.prototype.isPointInside = l.prototype.isPointInside;
  x.prototype.setDirtyCanvas = l.prototype.setDirtyCanvas;
  g.DragAndScale = A;
  A.prototype.bindEvents = function(a) {
    this.last_mouse = new Float32Array(2);
    this._binded_mouse_callback = this.onMouse.bind(this);
    g.pointerListenerAdd(a, "down", this._binded_mouse_callback);
    g.pointerListenerAdd(a, "move", this._binded_mouse_callback);
    g.pointerListenerAdd(a, "up", this._binded_mouse_callback);
    a.addEventListener("mousewheel", this._binded_mouse_callback, !1);
    a.addEventListener("wheel", this._binded_mouse_callback, !1);
  };
  A.prototype.computeVisibleArea = function(a) {
    if (this.element) {
      var b = this.element.width, c = this.element.height, e = -this.offset[0], d = -this.offset[1];
      a && (e += a[0] / this.scale, d += a[1] / this.scale, b = a[2], c = a[3]);
      a = e + b / this.scale;
      c = d + c / this.scale;
      this.visible_area[0] = e;
      this.visible_area[1] = d;
      this.visible_area[2] = a - e;
      this.visible_area[3] = c - d;
    } else {
      this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;
    }
  };
  A.prototype.onMouse = function(a) {
    if (this.enabled) {
      var b = this.element, c = b.getBoundingClientRect(), e = a.clientX - c.left;
      c = a.clientY - c.top;
      a.canvasx = e;
      a.canvasy = c;
      a.dragging = this.dragging;
      var d = !this.viewport || this.viewport && e >= this.viewport[0] && e < this.viewport[0] + this.viewport[2] && c >= this.viewport[1] && c < this.viewport[1] + this.viewport[3], f = !1;
      this.onmouse && (f = this.onmouse(a));
      a.type == g.pointerevents_method + "down" && d ? (this.dragging = !0, g.pointerListenerRemove(b, "move", this._binded_mouse_callback), g.pointerListenerAdd(document, "move", this._binded_mouse_callback), g.pointerListenerAdd(document, "up", this._binded_mouse_callback)) : a.type == g.pointerevents_method + "move" ? f || (b = e - this.last_mouse[0], f = c - this.last_mouse[1], this.dragging && this.mouseDrag(b, f)) : a.type == g.pointerevents_method + "up" ? (this.dragging = !1, g.pointerListenerRemove(document, 
      "move", this._binded_mouse_callback), g.pointerListenerRemove(document, "up", this._binded_mouse_callback), g.pointerListenerAdd(b, "move", this._binded_mouse_callback)) : !d || "mousewheel" != a.type && "wheel" != a.type && "DOMMouseScroll" != a.type || (a.eventType = "mousewheel", a.wheel = "wheel" == a.type ? -a.deltaY : null != a.wheelDeltaY ? a.wheelDeltaY : -60 * a.detail, a.delta = a.wheelDelta ? a.wheelDelta / 40 : a.deltaY ? -a.deltaY / 3 : 0, this.changeDeltaScale(1.0 + 0.05 * a.delta));
      this.last_mouse[0] = e;
      this.last_mouse[1] = c;
      if (d) {
        return a.preventDefault(), a.stopPropagation(), !1;
      }
    }
  };
  A.prototype.toCanvasContext = function(a) {
    a.scale(this.scale, this.scale);
    a.translate(this.offset[0], this.offset[1]);
  };
  A.prototype.convertOffsetToCanvas = function(a) {
    return [(a[0] + this.offset[0]) * this.scale, (a[1] + this.offset[1]) * this.scale];
  };
  A.prototype.convertCanvasToOffset = function(a, b) {
    b = b || [0, 0];
    b[0] = a[0] / this.scale - this.offset[0];
    b[1] = a[1] / this.scale - this.offset[1];
    return b;
  };
  A.prototype.mouseDrag = function(a, b) {
    this.offset[0] += a / this.scale;
    this.offset[1] += b / this.scale;
    if (this.onredraw) {
      this.onredraw(this);
    }
  };
  A.prototype.changeScale = function(a, b) {
    a < this.min_scale ? a = this.min_scale : a > this.max_scale && (a = this.max_scale);
    if (a != this.scale && this.element) {
      var c = this.element.getBoundingClientRect();
      if (c && (b = b || [0.5 * c.width, 0.5 * c.height], c = this.convertCanvasToOffset(b), this.scale = a, 0.01 > Math.abs(this.scale - 1) && (this.scale = 1), a = this.convertCanvasToOffset(b), a = [a[0] - c[0], a[1] - c[1]], this.offset[0] += a[0], this.offset[1] += a[1], this.onredraw)) {
        this.onredraw(this);
      }
    }
  };
  A.prototype.changeDeltaScale = function(a, b) {
    this.changeScale(this.scale * a, b);
  };
  A.prototype.reset = function() {
    this.scale = 1;
    this.offset[0] = 0;
    this.offset[1] = 0;
  };
  t.LGraphCanvas = g.LGraphCanvas = n;
  n.DEFAULT_BACKGROUND_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=";
  n.link_type_colors = {"-1":g.EVENT_LINK_COLOR, number:"#26547C", float:"#26547C", uint:"#FFD166", boolean:"#EF476F", bool:"#EF476F", float3:"#FFD166", float2:"#45D592", float4:"#06D6A0", string:"#77F", node:"#DCA"};
  n.gradients = {};
  n.prototype.clear = function() {
    this.fps = this.render_time = this.last_draw_time = this.frame = 0;
    this.dragging_rectangle = null;
    this.selected_nodes = {};
    this.selected_group = null;
    this.visible_nodes = [];
    this.connecting_node = this.node_capturing_input = this.node_over = this.node_dragged = null;
    this.highlighted_links = {};
    this.dragging_canvas = !1;
    this.dirty_bgcanvas = this.dirty_canvas = !0;
    this.node_widget = this.node_in_panel = this.dirty_area = null;
    this.last_mouse = [0, 0];
    this.last_mouseclick = 0;
    this.pointer_is_double = this.pointer_is_down = !1;
    this.visible_area.set([0, 0, 0, 0]);
    if (this.onClear) {
      this.onClear();
    }
  };
  n.prototype.setGraph = function(a, b) {
    this.graph != a && (b || this.clear(), !a && this.graph ? this.graph.detachCanvas(this) : (a.attachCanvas(this), this._graph_stack && (this._graph_stack = null), this.setDirty(!0, !0)));
  };
  n.prototype.getTopGraph = function() {
    return this._graph_stack.length ? this._graph_stack[0] : this.graph;
  };
  n.prototype.openSubgraph = function(a) {
    if (!a) {
      throw "graph cannot be null";
    }
    if (this.graph == a) {
      throw "graph cannot be the same";
    }
    this.clear();
    this.graph && (this._graph_stack || (this._graph_stack = []), this._graph_stack.push(this.graph));
    a.attachCanvas(this);
    this.checkPanels();
    this.setDirty(!0, !0);
  };
  n.prototype.closeSubgraph = function() {
    if (this._graph_stack && 0 != this._graph_stack.length) {
      var a = this.graph._subgraph_node, b = this._graph_stack.pop();
      this.selected_nodes = {};
      this.highlighted_links = {};
      b.attachCanvas(this);
      this.setDirty(!0, !0);
      a && (this.centerOnNode(a), this.selectNodes([a]));
      this.ds.offset = [0, 0];
      this.ds.scale = 1;
    }
  };
  n.prototype.getCurrentGraph = function() {
    return this.graph;
  };
  n.prototype.setCanvas = function(a, b) {
    if (a && a.constructor === String && (a = document.getElementById(a), !a)) {
      throw "Error creating LiteGraph canvas: Canvas not found";
    }
    if (a !== this.canvas && (!a && this.canvas && (b || this.unbindEvents()), this.canvas = a, this.ds.element = a)) {
      a.className += " lgraphcanvas";
      a.data = this;
      a.tabindex = "1";
      this.bgcanvas = null;
      this.bgcanvas || (this.bgcanvas = document.createElement("canvas"), this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height);
      if (null == a.getContext) {
        if ("canvas" != a.localName) {
          throw "Element supplied for LGraphCanvas must be a <canvas> element, you passed a " + a.localName;
        }
        throw "This browser doesn't support Canvas";
      }
      null == (this.ctx = a.getContext("2d")) && (a.webgl_enabled || console.warn("This canvas seems to be WebGL, enabling WebGL renderer"), this.enableWebGL());
      b || this.bindEvents();
    }
  };
  n.prototype._doNothing = function(a) {
    a.preventDefault();
    return !1;
  };
  n.prototype._doReturnTrue = function(a) {
    a.preventDefault();
    return !0;
  };
  n.prototype.bindEvents = function() {
    if (this._events_binded) {
      console.warn("LGraphCanvas: events already binded");
    } else {
      var a = this.canvas, b = this.getCanvasWindow().document;
      this._mousedown_callback = this.processMouseDown.bind(this);
      this._mousewheel_callback = this.processMouseWheel.bind(this);
      this._mousemove_callback = this.processMouseMove.bind(this);
      this._mouseup_callback = this.processMouseUp.bind(this);
      g.pointerListenerAdd(a, "down", this._mousedown_callback, !0);
      a.addEventListener("mousewheel", this._mousewheel_callback, !1);
      g.pointerListenerAdd(a, "up", this._mouseup_callback, !0);
      g.pointerListenerAdd(a, "move", this._mousemove_callback);
      a.addEventListener("contextmenu", this._doNothing);
      a.addEventListener("DOMMouseScroll", this._mousewheel_callback, !1);
      this._key_callback = this.processKey.bind(this);
      a.addEventListener("keydown", this._key_callback, !0);
      b.addEventListener("keyup", this._key_callback, !0);
      this._ondrop_callback = this.processDrop.bind(this);
      a.addEventListener("dragover", this._doNothing, !1);
      a.addEventListener("dragend", this._doNothing, !1);
      a.addEventListener("drop", this._ondrop_callback, !1);
      a.addEventListener("dragenter", this._doReturnTrue, !1);
      this._events_binded = !0;
    }
  };
  n.prototype.unbindEvents = function() {
    if (this._events_binded) {
      var a = this.getCanvasWindow().document;
      g.pointerListenerRemove(this.canvas, "move", this._mousedown_callback);
      g.pointerListenerRemove(this.canvas, "up", this._mousedown_callback);
      g.pointerListenerRemove(this.canvas, "down", this._mousedown_callback);
      this.canvas.removeEventListener("mousewheel", this._mousewheel_callback);
      this.canvas.removeEventListener("DOMMouseScroll", this._mousewheel_callback);
      this.canvas.removeEventListener("keydown", this._key_callback);
      a.removeEventListener("keyup", this._key_callback);
      this.canvas.removeEventListener("contextmenu", this._doNothing);
      this.canvas.removeEventListener("drop", this._ondrop_callback);
      this.canvas.removeEventListener("dragenter", this._doReturnTrue);
      this._ondrop_callback = this._key_callback = this._mousewheel_callback = this._mousedown_callback = null;
      this._events_binded = !1;
    } else {
      console.warn("LGraphCanvas: no events binded");
    }
  };
  n.getFileExtension = function(a) {
    var b = a.indexOf("?");
    -1 != b && (a = a.substr(0, b));
    b = a.lastIndexOf(".");
    return -1 == b ? "" : a.substr(b + 1).toLowerCase();
  };
  n.prototype.enableWebGL = function() {
    this.gl = this.ctx = enableWebGLCanvas(this.canvas);
    this.ctx.webgl = !0;
    this.bgcanvas = this.canvas;
    this.bgctx = this.gl;
    this.canvas.webgl_enabled = !0;
  };
  n.prototype.setDirty = function(a, b) {
    a && (this.dirty_canvas = !0);
    b && (this.dirty_bgcanvas = !0);
  };
  n.prototype.getCanvasWindow = function() {
    if (!this.canvas) {
      return window;
    }
    var a = this.canvas.ownerDocument;
    return a.defaultView || a.parentWindow;
  };
  n.prototype.startRendering = function() {
    function a() {
      this.pause_rendering || this.draw();
      var b = this.getCanvasWindow();
      this.is_rendering && b.requestAnimationFrame(a.bind(this));
    }
    this.is_rendering || (this.is_rendering = !0, a.call(this));
  };
  n.prototype.stopRendering = function() {
    this.is_rendering = !1;
  };
  n.prototype.blockClick = function() {
    this.block_click = !0;
    this.last_mouseclick = 0;
  };
  n.prototype.processMouseDown = function(a) {
    this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0);
    if (this.graph) {
      this.adjustMouseEvent(a);
      var b = this.getCanvasWindow();
      n.active_canvas = this;
      var c = this, e = a.clientX, d = a.clientY;
      this.ds.viewport = this.viewport;
      e = !this.viewport || this.viewport && e >= this.viewport[0] && e < this.viewport[0] + this.viewport[2] && d >= this.viewport[1] && d < this.viewport[1] + this.viewport[3];
      this.options.skip_events || (g.pointerListenerRemove(this.canvas, "move", this._mousemove_callback), g.pointerListenerAdd(b.document, "move", this._mousemove_callback, !0), g.pointerListenerAdd(b.document, "up", this._mouseup_callback, !0));
      if (e) {
        var f = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes, 5);
        e = !1;
        d = g.getTime();
        var h = void 0 === a.isPrimary || !a.isPrimary;
        d = 300 > d - this.last_mouseclick && h;
        this.mouse[0] = a.clientX;
        this.mouse[1] = a.clientY;
        this.graph_mouse[0] = a.canvasX;
        this.graph_mouse[1] = a.canvasY;
        this.last_click_position = [this.mouse[0], this.mouse[1]];
        this.pointer_is_double = this.pointer_is_down && h ? !0 : !1;
        this.pointer_is_down = !0;
        this.canvas.focus();
        g.closeAllContextMenus(b);
        if (!this.onMouse || 1 != this.onMouse(a)) {
          if (1 != a.which || this.pointer_is_double) {
            if (2 == a.which) {
              if (g.middle_click_canvas_dragging) {
                this.dragging_canvas = !0;
              } else {
                if (g.middle_click_slot_add_default_node && f && this.allow_interaction && !e && !this.read_only && !this.connecting_node && !f.flags.collapsed && !this.live_mode) {
                  d = e = h = !1;
                  if (f.outputs) {
                    for (u = 0, k = f.outputs.length; u < k; ++u) {
                      if (q = f.outputs[u], r = f.getConnectionPos(!1, u), B(a.canvasX, a.canvasY, r[0] - 15, r[1] - 10, 30, 20)) {
                        h = q;
                        e = u;
                        d = !0;
                        break;
                      }
                    }
                  }
                  if (f.inputs) {
                    for (u = 0, k = f.inputs.length; u < k; ++u) {
                      if (q = f.inputs[u], r = f.getConnectionPos(!0, u), B(a.canvasX, a.canvasY, r[0] - 15, r[1] - 10, 30, 20)) {
                        h = q;
                        e = u;
                        d = !1;
                        break;
                      }
                    }
                  }
                  h && !1 !== e && (u = 0.5 - (e + 1) / (d ? f.outputs.length : f.inputs.length), h = f.getBounding(), this.createDefaultNodeForSlot({nodeFrom:d ? f : null, slotFrom:d ? e : null, nodeTo:d ? null : f, slotTo:d ? null : e, position:[d ? h[0] + h[2] : h[0], a.canvasY - 80], nodeType:"AUTO", posAdd:[d ? 30 : -30, 130 * -u], posSizeFix:[d ? 0 : -1, 0]}));
                }
              }
            } else {
              3 != a.which && !this.pointer_is_double || !this.allow_interaction || e || this.read_only || (f && (Object.keys(this.selected_nodes).length && (this.selected_nodes[f.id] || a.shiftKey || a.ctrlKey || a.metaKey) ? this.selected_nodes[f.id] || this.selectNodes([f], !0) : this.selectNodes([f])), this.processContextMenu(f, a));
            }
          } else {
            a.ctrlKey && (this.dragging_rectangle = new Float32Array(4), this.dragging_rectangle[0] = a.canvasX, this.dragging_rectangle[1] = a.canvasY, this.dragging_rectangle[2] = 1, this.dragging_rectangle[3] = 1, e = !0);
            g.alt_drag_do_clone_nodes && a.altKey && f && this.allow_interaction && !e && !this.read_only && (cloned = f.clone()) && (cloned.pos[0] += 5, cloned.pos[1] += 5, this.graph.add(cloned, !1, {doCalcSize:!1}), f = cloned, e = !0, u || (this.allow_dragnodes && (this.graph.beforeChange(), this.node_dragged = f), this.selected_nodes[f.id] || this.processNodeSelected(f, a)));
            h = !1;
            if (f && this.allow_interaction && !e && !this.read_only) {
              if (!this.live_mode && !f.flags.pinned && (this.bringToFront(f), f.onBringToFront)) {
                f.onBringToFront(this);
              }
              if (!this.connecting_node && !f.flags.collapsed && !this.live_mode) {
                if (!e && !1 !== f.resizable && B(a.canvasX, a.canvasY, f.pos[0] + f.size[0] - 5, f.pos[1] + f.size[1] - 5, 10, 10)) {
                  this.graph.beforeChange(), this.resizing_node = f, this.canvas.style.cursor = "se-resize", e = !0;
                } else {
                  if (f.outputs) {
                    u = 0;
                    for (var k = f.outputs.length; u < k; ++u) {
                      var q = f.outputs[u], r = f.getConnectionPos(!1, u);
                      if (B(a.canvasX, a.canvasY, r[0] - 15, r[1] - 10, 30, 20) && (!1 !== q.visible || g.draw_invisible_connections)) {
                        this.connecting_node = f;
                        this.connecting_output = q;
                        this.connecting_output.slot_index = u;
                        this.connecting_pos = f.getConnectionPos(!1, u);
                        this.connecting_slot = u;
                        g.shift_click_do_break_link_from && a.shiftKey && f.disconnectOutput(u);
                        if (d) {
                          if (f.onOutputDblClick) {
                            f.onOutputDblClick(u, a);
                          }
                        } else {
                          if (f.onOutputClick) {
                            f.onOutputClick(u, a);
                          }
                        }
                        e = !0;
                        break;
                      }
                    }
                  }
                  if (f.inputs) {
                    for (u = 0, k = f.inputs.length; u < k; ++u) {
                      if (q = f.inputs[u], r = f.getConnectionPos(!0, u), B(a.canvasX, a.canvasY, r[0] - 15, r[1] - 10, 30, 20) && (!1 !== q.visible || g.draw_invisible_connections)) {
                        if (d) {
                          if (f.onInputDblClick) {
                            f.onInputDblClick(u, a);
                          }
                        } else {
                          if (f.onInputClick) {
                            f.onInputClick(u, a);
                          }
                        }
                        null !== q.link && (r = this.graph.links[q.link], g.click_do_break_link_to && (f.disconnectInput(u), e = this.dirty_bgcanvas = !0), this.allow_reconnect_links || a.shiftKey) && (g.click_do_break_link_to || f.disconnectInput(u), this.connecting_node = this.graph._nodes_by_id[r.origin_id], this.connecting_slot = r.origin_slot, this.connecting_output = this.connecting_node.outputs[this.connecting_slot], this.connecting_pos = this.connecting_node.getConnectionPos(!1, this.connecting_slot), 
                        e = this.dirty_bgcanvas = !0);
                        e || (this.connecting_node = f, this.connecting_input = q, this.connecting_input.slot_index = u, this.connecting_pos = f.getConnectionPos(!0, u), this.connecting_slot = u, e = this.dirty_bgcanvas = !0);
                      }
                    }
                  }
                }
              }
              if (!e) {
                var u = !1;
                k = [a.canvasX - f.pos[0], a.canvasY - f.pos[1]];
                if (r = this.processNodeWidgets(f, this.graph_mouse, a)) {
                  u = !0, this.node_widget = [f, r];
                }
                if (d && this.selected_nodes[f.id]) {
                  if (f.onDblClick) {
                    f.onDblClick(a, k, this);
                  }
                  this.processNodeDblClicked(f);
                  u = !0;
                }
                f.onMouseDown && f.onMouseDown(a, k, this) ? u = !0 : (f.subgraph && !f.skip_subgraph_button && !f.flags.collapsed && k[0] > f.size[0] - g.NODE_TITLE_HEIGHT && 0 > k[1] && (c = this, setTimeout(function() {
                  c.openSubgraph(f.subgraph);
                }, 10)), this.live_mode && (u = h = !0));
                u || (this.allow_dragnodes && (this.graph.beforeChange(), this.node_dragged = f), this.selected_nodes[f.id] || this.processNodeSelected(f, a));
                this.dirty_canvas = !0;
              }
            } else {
              if (!e) {
                if (!this.read_only) {
                  for (u = 0; u < this.visible_links.length; ++u) {
                    if (h = this.visible_links[u], k = h._pos, !(!k || a.canvasX < k[0] - 4 || a.canvasX > k[0] + 4 || a.canvasY < k[1] - 4 || a.canvasY > k[1] + 4)) {
                      this.showLinkMenu(h, a);
                      this.over_link_center = null;
                      break;
                    }
                  }
                }
                this.selected_group = this.graph.getGroupOnPos(a.canvasX, a.canvasY);
                this.selected_group_resizing = !1;
                this.selected_group && !this.read_only && (a.ctrlKey && (this.dragging_rectangle = null), 10 > G([a.canvasX, a.canvasY], [this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1]]) * this.ds.scale ? this.selected_group_resizing = !0 : this.selected_group.recomputeInsideNodes());
                d && !this.read_only && this.allow_searchbox && (this.showSearchBox(a), a.preventDefault(), a.stopPropagation());
                h = !0;
              }
            }
            !e && h && this.allow_dragcanvas && (this.dragging_canvas = !0);
          }
          this.last_mouse[0] = a.clientX;
          this.last_mouse[1] = a.clientY;
          this.last_mouseclick = g.getTime();
          this.last_mouse_dragging = !0;
          this.graph.change();
          (!b.document.activeElement || "input" != b.document.activeElement.nodeName.toLowerCase() && "textarea" != b.document.activeElement.nodeName.toLowerCase()) && a.preventDefault();
          a.stopPropagation();
          if (this.onMouseDown) {
            this.onMouseDown(a);
          }
          return !1;
        }
      }
    }
  };
  n.prototype.processMouseMove = function(a) {
    var b = this;
    this.autoresize && this.resize();
    this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0);
    if (this.graph) {
      n.active_canvas = this;
      this.adjustMouseEvent(a);
      var c = [a.clientX, a.clientY];
      this.mouse[0] = c[0];
      this.mouse[1] = c[1];
      var e = [c[0] - this.last_mouse[0], c[1] - this.last_mouse[1]];
      this.last_mouse = c;
      this.graph_mouse[0] = a.canvasX;
      this.graph_mouse[1] = a.canvasY;
      if (this.block_click) {
        return a.preventDefault(), !1;
      }
      a.dragging = this.last_mouse_dragging;
      this.node_widget && (this.processNodeWidgets(this.node_widget[0], this.graph_mouse, a, this.node_widget[1]), this.dirty_canvas = !0);
      if (this.dragging_rectangle) {
        this.dragging_rectangle[2] = a.canvasX - this.dragging_rectangle[0], this.dragging_rectangle[3] = a.canvasY - this.dragging_rectangle[1], this.dirty_canvas = !0;
      } else {
        if (this.selected_group && !this.read_only) {
          this.selected_group_resizing ? this.selected_group.size = [a.canvasX - this.selected_group.pos[0], a.canvasY - this.selected_group.pos[1]] : (this.selected_group.move(e[0] / this.ds.scale, e[1] / this.ds.scale, a.ctrlKey), this.selected_group._nodes.length && (this.dirty_canvas = !0)), this.dirty_bgcanvas = !0;
        } else {
          if (this.dragging_canvas) {
            this.ds.offset[0] += e[0] / this.ds.scale, this.ds.offset[1] += e[1] / this.ds.scale, this.dirty_bgcanvas = this.dirty_canvas = !0;
          } else {
            if (this.allow_interaction && !this.read_only) {
              this.connecting_node && (this.dirty_canvas = !0);
              var d = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes);
              c = 0;
              for (var f = this.graph._nodes.length; c < f; ++c) {
                if (this.graph._nodes[c].mouseOver && d != this.graph._nodes[c]) {
                  this.graph._nodes[c].mouseOver = !1;
                  if (this.node_over && this.node_over.onMouseLeave) {
                    this.node_over.onMouseLeave(a);
                  }
                  this.node_over = null;
                  this.dirty_canvas = !0;
                }
              }
              if (d) {
                d.redraw_on_mouse && (this.dirty_canvas = !0);
                if (!d.mouseOver && (d.mouseOver = !0, this.node_over = d, this.dirty_canvas = !0, d.onMouseEnter)) {
                  d.onMouseEnter(a);
                }
                if (d.onMouseMove) {
                  d.onMouseMove(a, [a.canvasX - d.pos[0], a.canvasY - d.pos[1]], this);
                }
                if (this.node_dragged && d.constructor.can_be_dropped) {
                  this.dnd_nodes = this.dnd_nodes || [];
                  var h = this.graph.getNodesOnPos(a.canvasX, a.canvasY, this.visible_nodes).filter(function(a) {
                    return a != d && a.constructor.can_accept_drop;
                  });
                  h = h.sort(function(a, c) {
                    return b.graph._nodes.indexOf(c) - b.graph._nodes.indexOf(a);
                  }).slice(0, 1);
                  f = this.dnd_nodes.filter(function(a) {
                    return !h.includes(a);
                  });
                  var k = h.filter(function(a) {
                    return !b.dnd_nodes.includes(a);
                  });
                  f.forEach(function(a) {
                    if (a.onDropLeave) {
                      a.onDropLeave(d, b);
                    }
                  });
                  k.forEach(function(a) {
                    if (a.onDropEnter) {
                      a.onDropEnter(d, b);
                    }
                  });
                  h.forEach(function(c) {
                    return c.onDropMove && c.onDropMove(d, [a.canvasX - c.pos[0], a.canvasY - c.pos[1]], b);
                  });
                  this.dnd_nodes = h;
                }
                if (this.connecting_node) {
                  if (this.connecting_output) {
                    if (f = this._highlight_input || [0, 0], !this.isOverNodeBox(d, a.canvasX, a.canvasY)) {
                      if (k = this.isOverNodeInput(d, a.canvasX, a.canvasY, f), -1 != k && d.inputs[k] && !1 !== d.inputs[k].visible) {
                        var q = d.inputs[k].type;
                        g.isValidConnection(this.connecting_output.type, q) && (this._highlight_input = f, this._highlight_input_slot = d.inputs[k]);
                      } else {
                        this._highlight_input_slot = this._highlight_input = null;
                      }
                    }
                  } else {
                    this.connecting_input && (f = this._highlight_output || [0, 0], this.isOverNodeBox(d, a.canvasX, a.canvasY) || (k = this.isOverNodeOutput(d, a.canvasX, a.canvasY, f), -1 != k && d.outputs[k] && !1 !== d.outputs[k].visible ? (q = d.outputs[k].type, g.isValidConnection(this.connecting_input.type, q) && (this._highlight_output = f)) : this._highlight_output = null));
                  }
                }
                this.canvas && (B(a.canvasX, a.canvasY, d.pos[0] + d.size[0] - 5, d.pos[1] + d.size[1] - 5, 5, 5) ? this.canvas.style.cursor = "se-resize" : this.canvas.style.cursor = "crosshair");
              } else {
                f = null;
                for (c = 0; c < this.visible_links.length; ++c) {
                  if (k = this.visible_links[c], q = k._pos, !(!q || a.canvasX < q[0] - 4 || a.canvasX > q[0] + 4 || a.canvasY < q[1] - 4 || a.canvasY > q[1] + 4)) {
                    f = k;
                    break;
                  }
                }
                f != this.over_link_center && (this.over_link_center = f, this.dirty_canvas = !0);
                this.canvas && (this.canvas.style.cursor = "");
              }
              if (this.node_capturing_input && this.node_capturing_input != d && this.node_capturing_input.onMouseMove) {
                this.node_capturing_input.onMouseMove(a, [a.canvasX - this.node_capturing_input.pos[0], a.canvasY - this.node_capturing_input.pos[1]], this);
              }
              if (this.node_dragged && !this.live_mode) {
                for (c in this.selected_nodes) {
                  if (f = this.selected_nodes[c], f.pos[0] += e[0] / this.ds.scale, f.pos[1] += e[1] / this.ds.scale, f.onDrag) {
                    f.onDrag(this);
                  }
                }
                this.dirty_bgcanvas = this.dirty_canvas = !0;
              }
              this.resizing_node && !this.live_mode && (e = [a.canvasX - this.resizing_node.pos[0], a.canvasY - this.resizing_node.pos[1]], c = this.resizing_node.computeSize(), e[0] = Math.max(c[0], e[0]), e[1] = Math.max(c[1], e[1]), this.resizing_node.setSize(e), this.canvas.style.cursor = "se-resize", this.dirty_bgcanvas = this.dirty_canvas = !0);
            }
          }
        }
      }
      a.preventDefault();
      return !1;
    }
  };
  n.prototype.processMouseUp = function(a) {
    var b = this, c = void 0 === a.isPrimary || a.isPrimary;
    if (!c) {
      return !1;
    }
    this.set_canvas_dirty_on_mouse_event && (this.dirty_canvas = !0);
    if (this.graph) {
      var e = this.getCanvasWindow().document;
      n.active_canvas = this;
      this.options.skip_events || (g.pointerListenerRemove(e, "move", this._mousemove_callback, !0), g.pointerListenerAdd(this.canvas, "move", this._mousemove_callback, !0), g.pointerListenerRemove(e, "up", this._mouseup_callback, !0));
      this.adjustMouseEvent(a);
      e = g.getTime();
      a.click_time = e - this.last_mouseclick;
      this.last_mouse_dragging = !1;
      this.last_click_position = null;
      this.block_click && (this.block_click = !1);
      if (1 == a.which) {
        this.node_widget && this.processNodeWidgets(this.node_widget[0], this.graph_mouse, a);
        this.node_widget = null;
        this.selected_group && (this.selected_group.move(this.selected_group.pos[0] - Math.round(this.selected_group.pos[0]), this.selected_group.pos[1] - Math.round(this.selected_group.pos[1]), a.ctrlKey), this.selected_group.pos[0] = Math.round(this.selected_group.pos[0]), this.selected_group.pos[1] = Math.round(this.selected_group.pos[1]), this.selected_group._nodes.length && (this.dirty_canvas = !0), this.selected_group = null);
        this.selected_group_resizing = !1;
        var d = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes);
        if (this.dragging_rectangle) {
          if (this.graph) {
            e = this.graph._nodes;
            var f = new Float32Array(4), h = Math.abs(this.dragging_rectangle[2]), k = Math.abs(this.dragging_rectangle[3]), q = 0 > this.dragging_rectangle[3] ? this.dragging_rectangle[1] - k : this.dragging_rectangle[1];
            this.dragging_rectangle[0] = 0 > this.dragging_rectangle[2] ? this.dragging_rectangle[0] - h : this.dragging_rectangle[0];
            this.dragging_rectangle[1] = q;
            this.dragging_rectangle[2] = h;
            this.dragging_rectangle[3] = k;
            if (!d || 10 < h && 10 < k) {
              d = [];
              for (h = 0; h < e.length; ++h) {
                k = e[h], k.getBounding(f), H(this.dragging_rectangle, f) && d.push(k);
              }
              d.length && this.selectNodes(d, a.shiftKey);
            } else {
              this.selectNodes([d], a.shiftKey || a.ctrlKey);
            }
          }
          this.dragging_rectangle = null;
        } else {
          if (this.connecting_node) {
            this.dirty_bgcanvas = this.dirty_canvas = !0, e = (this.connecting_output || this.connecting_input).type, d ? this.connecting_output ? (f = this.isOverNodeInput(d, a.canvasX, a.canvasY), -1 != f ? this.connecting_node.connect(this.connecting_slot, d, f) : this.connecting_node.connectByType(this.connecting_slot, d, e)) : this.connecting_input && (f = this.isOverNodeOutput(d, a.canvasX, a.canvasY), -1 != f ? d.connect(f, this.connecting_node, this.connecting_slot) : this.connecting_node.connectByTypeOutput(this.connecting_slot, 
            d, e)) : g.release_link_on_empty_shows_menu && (a.shiftKey && this.allow_searchbox ? this.connecting_output ? this.showSearchBox(a, {node_from:this.connecting_node, slot_from:this.connecting_output, type_filter_in:this.connecting_output.type}) : this.connecting_input && this.showSearchBox(a, {node_to:this.connecting_node, slot_from:this.connecting_input, type_filter_out:this.connecting_input.type}) : this.connecting_output ? this.showConnectionMenu({nodeFrom:this.connecting_node, slotFrom:this.connecting_output, 
            e:a}) : this.connecting_input && this.showConnectionMenu({nodeTo:this.connecting_node, slotTo:this.connecting_input, e:a})), this.connecting_node = this.connecting_pos = this.connecting_input = this.connecting_output = null, this.connecting_slot = -1;
          } else {
            if (this.resizing_node) {
              this.dirty_bgcanvas = this.dirty_canvas = !0, this.graph.afterChange(this.resizing_node), this.resizing_node = null;
            } else {
              if (this.node_dragged) {
                (d = this.node_dragged) && 300 > a.click_time && B(a.canvasX, a.canvasY, d.pos[0], d.pos[1] - g.NODE_TITLE_HEIGHT, g.NODE_TITLE_HEIGHT, g.NODE_TITLE_HEIGHT) && d.collapse();
                this.dirty_bgcanvas = this.dirty_canvas = !0;
                this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);
                this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);
                (this.graph.config.align_to_grid || this.align_to_grid) && this.node_dragged.alignToGrid();
                if (this.onNodeMoved) {
                  this.onNodeMoved(this.node_dragged);
                }
                this.dnd_nodes && (this.dnd_nodes.forEach(function(a) {
                  if (a.onDrop) {
                    a.onDrop(b.node_dragged);
                  }
                }), this.dnd_nodes = null);
                this.graph.afterChange(this.node_dragged);
                this.node_dragged = null;
              } else {
                d = this.graph.getNodeOnPos(a.canvasX, a.canvasY, this.visible_nodes);
                !d && 300 > a.click_time && this.deselectAllNodes();
                this.dirty_canvas = !0;
                this.dragging_canvas = !1;
                if (this.node_over && this.node_over.onMouseUp) {
                  this.node_over.onMouseUp(a, [a.canvasX - this.node_over.pos[0], a.canvasY - this.node_over.pos[1]], this);
                }
                if (this.node_capturing_input && this.node_capturing_input.onMouseUp) {
                  this.node_capturing_input.onMouseUp(a, [a.canvasX - this.node_capturing_input.pos[0], a.canvasY - this.node_capturing_input.pos[1]]);
                }
              }
            }
          }
        }
      } else {
        2 == a.which ? (this.dirty_canvas = !0, this.dragging_canvas = !1) : 3 == a.which && (this.dirty_canvas = !0, this.dragging_canvas = !1);
      }
      c && (this.pointer_is_double = this.pointer_is_down = !1);
      this.graph.change();
      a.stopPropagation();
      a.preventDefault();
      return !1;
    }
  };
  n.prototype.processMouseWheel = function(a) {
    if (this.graph && this.allow_dragcanvas) {
      var b = null != a.wheelDeltaY ? a.wheelDeltaY : -60 * a.detail;
      this.adjustMouseEvent(a);
      var c = a.clientX, e = a.clientY;
      if (!this.viewport || this.viewport && c >= this.viewport[0] && c < this.viewport[0] + this.viewport[2] && e >= this.viewport[1] && e < this.viewport[1] + this.viewport[3]) {
        return c = this.ds.scale, 0 < b ? c *= 1.1 : 0 > b && (c *= 1 / 1.1), this.ds.changeScale(c, [a.clientX, a.clientY]), this.graph.change(), a.preventDefault(), !1;
      }
    }
  };
  n.prototype.isOverNodeBox = function(a, b, c) {
    var e = g.NODE_TITLE_HEIGHT;
    return B(b, c, a.pos[0] + 2, a.pos[1] + 2 - e, e - 4, e - 4) ? !0 : !1;
  };
  n.prototype.isOverNodeInput = function(a, b, c, e) {
    if (a.inputs) {
      for (var d = 0, f = a.inputs.length; d < f; ++d) {
        var h = a.getConnectionPos(!0, d);
        if (a.horizontal ? B(b, c, h[0] - 5, h[1] - 10, 10, 20) : B(b, c, h[0] - 10, h[1] - 5, 40, 10)) {
          return e && (e[0] = h[0], e[1] = h[1]), d;
        }
      }
    }
    return -1;
  };
  n.prototype.isOverNodeOutput = function(a, b, c, e) {
    if (a.outputs) {
      for (var d = 0, f = a.outputs.length; d < f; ++d) {
        var h = a.getConnectionPos(!1, d);
        if (a.horizontal ? B(b, c, h[0] - 5, h[1] - 10, 10, 20) : B(b, c, h[0] - 10, h[1] - 5, 40, 10)) {
          return e && (e[0] = h[0], e[1] = h[1]), d;
        }
      }
    }
    return -1;
  };
  n.prototype.processKey = function(a) {
    if (this.graph) {
      var b = !1;
      if ("input" != a.target.localName) {
        if ("keydown" == a.type) {
          if (32 == a.keyCode && (b = this.dragging_canvas = !0), 27 == a.keyCode && (this.node_panel && this.node_panel.close(), this.options_panel && this.options_panel.close(), b = !0), 65 == a.keyCode && a.ctrlKey && (this.selectNodes(), b = !0), "KeyC" == a.code && (a.metaKey || a.ctrlKey) && !a.shiftKey && this.selected_nodes && (this.copyToClipboard(), b = !0), "KeyV" != a.code || !a.metaKey && !a.ctrlKey || a.shiftKey || this.pasteFromClipboard(), 46 != a.keyCode && 8 != a.keyCode || "input" == 
          a.target.localName || "textarea" == a.target.localName || (this.deleteSelectedNodes(), b = !0), this.selected_nodes) {
            for (var c in this.selected_nodes) {
              if (this.selected_nodes[c].onKeyDown) {
                this.selected_nodes[c].onKeyDown(a);
              }
            }
          }
        } else {
          if ("keyup" == a.type && (32 == a.keyCode && (this.dragging_canvas = !1), this.selected_nodes)) {
            for (c in this.selected_nodes) {
              if (this.selected_nodes[c].onKeyUp) {
                this.selected_nodes[c].onKeyUp(a);
              }
            }
          }
        }
        this.graph.change();
        if (b) {
          return a.preventDefault(), a.stopImmediatePropagation(), !1;
        }
      }
    }
  };
  n.prototype.copyToClipboard = function() {
    var a = {nodes:[], links:[]}, b = 0, c = [], e;
    for (e in this.selected_nodes) {
      var d = this.selected_nodes[e];
      d._relative_id = b;
      c.push(d);
      b += 1;
    }
    for (e = 0; e < c.length; ++e) {
      if (d = c[e], b = d.clone()) {
        if (a.nodes.push(b.serialize()), d.inputs && d.inputs.length) {
          for (b = 0; b < d.inputs.length; ++b) {
            var f = d.inputs[b];
            if (f && null != f.link && (f = this.graph.links[f.link])) {
              var h = this.graph.getNodeById(f.origin_id);
              h && this.selected_nodes[h.id] && a.links.push([h._relative_id, f.origin_slot, d._relative_id, f.target_slot]);
            }
          }
        }
      } else {
        console.warn("node type not found: " + d.type);
      }
    }
    localStorage.setItem("litegrapheditor_clipboard", JSON.stringify(a));
  };
  n.prototype.pasteFromClipboard = function() {
    var a = localStorage.getItem("litegrapheditor_clipboard");
    if (a) {
      this.graph.beforeChange();
      a = JSON.parse(a);
      for (var b = !1, c = !1, e = 0; e < a.nodes.length; ++e) {
        b ? (b[0] > a.nodes[e].pos[0] && (b[0] = a.nodes[e].pos[0], c[0] = e), b[1] > a.nodes[e].pos[1] && (b[1] = a.nodes[e].pos[1], c[1] = e)) : (b = [a.nodes[e].pos[0], a.nodes[e].pos[1]], c = [e, e]);
      }
      c = [];
      for (e = 0; e < a.nodes.length; ++e) {
        var d = a.nodes[e], f = g.createNode(d.type);
        f && (f.configure(d), f.pos[0] += this.graph_mouse[0] - b[0], f.pos[1] += this.graph_mouse[1] - b[1], this.graph.add(f, {doProcessChange:!1}), c.push(f));
      }
      for (e = 0; e < a.links.length; ++e) {
        b = a.links[e], d = c[b[0]], f = c[b[2]], d && f ? d.connect(b[1], f, b[3]) : console.warn("Warning, nodes missing on pasting");
      }
      this.selectNodes(c);
      this.graph.afterChange();
    }
  };
  n.prototype.processDrop = function(a) {
    a.preventDefault();
    this.adjustMouseEvent(a);
    var b = a.clientX, c = a.clientY;
    if (!this.viewport || this.viewport && b >= this.viewport[0] && b < this.viewport[0] + this.viewport[2] && c >= this.viewport[1] && c < this.viewport[1] + this.viewport[3]) {
      b = [a.canvasX, a.canvasY];
      var e = this.graph ? this.graph.getNodeOnPos(b[0], b[1]) : null;
      if (e) {
        if ((e.onDropFile || e.onDropData) && (b = a.dataTransfer.files) && b.length) {
          for (c = 0; c < b.length; c++) {
            var d = a.dataTransfer.files[0], f = d.name;
            n.getFileExtension(f);
            if (e.onDropFile) {
              e.onDropFile(d);
            }
            if (e.onDropData) {
              var h = new FileReader;
              h.onload = function(a) {
                e.onDropData(a.target.result, f, d);
              };
              var g = d.type.split("/")[0];
              "text" == g || "" == g ? h.readAsText(d) : "image" == g ? h.readAsDataURL(d) : h.readAsArrayBuffer(d);
            }
          }
        }
        return e.onDropItem && e.onDropItem(event) ? !0 : this.onDropItem ? this.onDropItem(event) : !1;
      }
      b = null;
      this.onDropItem && (b = this.onDropItem(event));
      b || this.checkDropItem(a);
    }
  };
  n.prototype.checkDropItem = function(a) {
    if (a.dataTransfer.files.length) {
      var b = a.dataTransfer.files[0], c = n.getFileExtension(b.name).toLowerCase();
      if (c = g.node_types_by_file_extension[c]) {
        this.graph.beforeChange();
        c = g.createNode(c.type);
        c.pos = [a.canvasX, a.canvasY];
        this.graph.add(c);
        if (c.onDropFile) {
          c.onDropFile(b);
        }
        this.graph.afterChange();
      }
    }
  };
  n.prototype.processNodeDblClicked = function(a) {
    if (this.onShowNodePanel) {
      this.onShowNodePanel(a);
    } else {
      this.showShowNodePanel(a);
    }
    if (this.onNodeDblClicked) {
      this.onNodeDblClicked(a);
    }
    this.setDirty(!0);
  };
  n.prototype.processNodeSelected = function(a, b) {
    this.selectNode(a, b && (b.shiftKey || b.ctrlKey));
    if (this.onNodeSelected) {
      this.onNodeSelected(a);
    }
  };
  n.prototype.selectNode = function(a, b) {
    null == a ? this.deselectAllNodes() : this.selectNodes([a], b);
  };
  n.prototype.selectNodes = function(a, b) {
    b || this.deselectAllNodes();
    a = a || this.graph._nodes;
    "string" == typeof a && (a = [a]);
    for (var c in a) {
      if (b = a[c], !b.is_selected) {
        if (!b.is_selected && b.onSelected) {
          b.onSelected();
        }
        b.is_selected = !0;
        this.selected_nodes[b.id] = b;
        if (b.inputs) {
          for (var e = 0; e < b.inputs.length; ++e) {
            this.highlighted_links[b.inputs[e].link] = !0;
          }
        }
        if (b.outputs) {
          for (e = 0; e < b.outputs.length; ++e) {
            var d = b.outputs[e];
            if (d.links) {
              for (var f = 0; f < d.links.length; ++f) {
                this.highlighted_links[d.links[f]] = !0;
              }
            }
          }
        }
      }
    }
    if (this.onSelectionChange) {
      this.onSelectionChange(this.selected_nodes);
    }
    this.setDirty(!0);
  };
  n.prototype.deselectNode = function(a) {
    if (a.is_selected) {
      if (a.onDeselected) {
        a.onDeselected();
      }
      a.is_selected = !1;
      if (this.onNodeDeselected) {
        this.onNodeDeselected(a);
      }
      if (a.inputs) {
        for (var b = 0; b < a.inputs.length; ++b) {
          delete this.highlighted_links[a.inputs[b].link];
        }
      }
      if (a.outputs) {
        for (b = 0; b < a.outputs.length; ++b) {
          var c = a.outputs[b];
          if (c.links) {
            for (var e = 0; e < c.links.length; ++e) {
              delete this.highlighted_links[c.links[e]];
            }
          }
        }
      }
    }
  };
  n.prototype.deselectAllNodes = function() {
    if (this.graph) {
      for (var a = this.graph._nodes, b = 0, c = a.length; b < c; ++b) {
        var e = a[b];
        if (e.is_selected) {
          if (e.onDeselected) {
            e.onDeselected();
          }
          e.is_selected = !1;
          if (this.onNodeDeselected) {
            this.onNodeDeselected(e);
          }
        }
      }
      this.selected_nodes = {};
      this.current_node = null;
      this.highlighted_links = {};
      if (this.onSelectionChange) {
        this.onSelectionChange(this.selected_nodes);
      }
      this.setDirty(!0);
    }
  };
  n.prototype.deleteSelectedNodes = function() {
    this.graph.beforeChange();
    for (var a in this.selected_nodes) {
      var b = this.selected_nodes[a];
      if (!b.block_delete) {
        if (b.inputs && b.inputs.length && b.outputs && b.outputs.length && g.isValidConnection(b.inputs[0].type, b.outputs[0].type) && b.inputs[0].link && b.outputs[0].links && b.outputs[0].links.length) {
          var c = b.graph.links[b.inputs[0].link], e = b.graph.links[b.outputs[0].links[0]], d = b.getInputNode(0), f = b.getOutputNodes(0)[0];
          d && f && d.connect(c.origin_slot, f, e.target_slot);
        }
        this.graph.remove(b);
        if (this.onNodeDeselected) {
          this.onNodeDeselected(b);
        }
      }
    }
    this.selected_nodes = {};
    this.current_node = null;
    this.highlighted_links = {};
    this.setDirty(!0);
    this.graph.afterChange();
  };
  n.prototype.centerOnNode = function(a) {
    this.ds.offset[0] = -a.pos[0] - 0.5 * a.size[0] + 0.5 * this.canvas.width / this.ds.scale;
    this.ds.offset[1] = -a.pos[1] - 0.5 * a.size[1] + 0.5 * this.canvas.height / this.ds.scale;
    this.setDirty(!0, !0);
  };
  n.prototype.adjustMouseEvent = function(a) {
    if (this.canvas) {
      var b = this.canvas.getBoundingClientRect();
      var c = a.clientX - b.left;
      b = a.clientY - b.top;
    } else {
      c = a.clientX, b = a.clientY;
    }
    a.deltaX = c - this.last_mouse_position[0];
    a.deltaY = b - this.last_mouse_position[1];
    this.last_mouse_position[0] = c;
    this.last_mouse_position[1] = b;
    a.canvasX = c / this.ds.scale - this.ds.offset[0];
    a.canvasY = b / this.ds.scale - this.ds.offset[1];
  };
  n.prototype.setZoom = function(a, b) {
    this.ds.changeScale(a, b);
    this.dirty_bgcanvas = this.dirty_canvas = !0;
  };
  n.prototype.convertOffsetToCanvas = function(a, b) {
    return this.ds.convertOffsetToCanvas(a, b);
  };
  n.prototype.convertCanvasToOffset = function(a, b) {
    return this.ds.convertCanvasToOffset(a, b);
  };
  n.prototype.convertEventToCanvasOffset = function(a) {
    var b = this.canvas.getBoundingClientRect();
    return this.convertCanvasToOffset([a.clientX - b.left, a.clientY - b.top]);
  };
  n.prototype.bringToFront = function(a) {
    var b = this.graph._nodes.indexOf(a);
    -1 != b && (this.graph._nodes.splice(b, 1), this.graph._nodes.push(a));
  };
  n.prototype.sendToBack = function(a) {
    var b = this.graph._nodes.indexOf(a);
    -1 != b && (this.graph._nodes.splice(b, 1), this.graph._nodes.unshift(a));
  };
  var J = new Float32Array(4);
  n.prototype.computeVisibleNodes = function(a, b) {
    b = b || [];
    b.length = 0;
    a = a || this.graph._nodes;
    for (var c = 0, e = a.length; c < e; ++c) {
      var d = a[c];
      (!this.live_mode || d.onDrawBackground || d.onDrawForeground) && H(this.visible_area, d.getBounding(J)) && b.push(d);
    }
    return b;
  };
  n.prototype.draw = function(a, b) {
    if (this.canvas && 0 != this.canvas.width && 0 != this.canvas.height) {
      var c = g.getTime();
      this.render_time = 0.001 * (c - this.last_draw_time);
      this.last_draw_time = c;
      this.graph && this.ds.computeVisibleArea(this.viewport);
      (this.dirty_bgcanvas || b || this.always_render_background || this.graph && this.graph._last_trigger_time && 1000 > c - this.graph._last_trigger_time) && this.drawBackCanvas();
      (this.dirty_canvas || a) && this.drawFrontCanvas();
      this.fps = this.render_time ? 1.0 / this.render_time : 0;
      this.frame += 1;
    }
  };
  n.prototype.drawFrontCanvas = function() {
    this.dirty_canvas = !1;
    this.ctx || (this.ctx = this.bgcanvas.getContext("2d"));
    var a = this.ctx;
    if (a) {
      var b = this.canvas;
      a.start2D && !this.viewport && (a.start2D(), a.restore(), a.setTransform(1, 0, 0, 1, 0, 0));
      var c = this.viewport || this.dirty_area;
      c && (a.save(), a.beginPath(), a.rect(c[0], c[1], c[2], c[3]), a.clip());
      this.clear_background && (c ? a.clearRect(c[0], c[1], c[2], c[3]) : a.clearRect(0, 0, b.width, b.height));
      this.bgcanvas == this.canvas ? this.drawBackCanvas() : a.drawImage(this.bgcanvas, 0, 0);
      if (this.onRender) {
        this.onRender(b, a);
      }
      this.show_info && this.renderInfo(a, c ? c[0] : 0, c ? c[1] : 0);
      if (this.graph) {
        a.save();
        this.ds.toCanvasContext(a);
        b = this.computeVisibleNodes(null, this.visible_nodes);
        for (var e = 0; e < b.length; ++e) {
          var d = b[e];
          a.save();
          a.translate(d.pos[0], d.pos[1]);
          this.drawNode(d, a);
          a.restore();
        }
        this.render_execution_order && this.drawExecutionOrder(a);
        this.graph.config.links_ontop && (this.live_mode || this.drawConnections(a));
        if (null != this.connecting_pos) {
          a.lineWidth = this.connections_width;
          d = this.connecting_output || this.connecting_input;
          b = d.type;
          e = d.dir;
          null == e && (e = this.connecting_output ? this.connecting_node.horizontal ? g.DOWN : g.RIGHT : this.connecting_node.horizontal ? g.UP : g.LEFT);
          var f = d.shape;
          switch(b) {
            case g.EVENT:
              d = g.EVENT_LINK_COLOR;
              break;
            default:
              d = g.CONNECTING_LINK_COLOR;
          }
          this.renderLink(a, this.connecting_pos, [this.graph_mouse[0], this.graph_mouse[1]], null, !1, null, d, e, g.CENTER);
          a.beginPath();
          b === g.EVENT || f === g.BOX_SHAPE ? (a.rect(this.connecting_pos[0] - 6 + 0.5, this.connecting_pos[1] - 5 + 0.5, 14, 10), a.fill(), a.beginPath(), a.rect(this.graph_mouse[0] - 6 + 0.5, this.graph_mouse[1] - 5 + 0.5, 14, 10)) : f === g.ARROW_SHAPE ? (a.moveTo(this.connecting_pos[0] + 8, this.connecting_pos[1] + 0.5), a.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] + 6 + 0.5), a.lineTo(this.connecting_pos[0] - 4, this.connecting_pos[1] - 6 + 0.5), a.closePath()) : (a.arc(this.connecting_pos[0], 
          this.connecting_pos[1], 4, 0, 2 * Math.PI), a.fill(), a.beginPath(), a.arc(this.graph_mouse[0], this.graph_mouse[1], 4, 0, 2 * Math.PI));
          a.fill();
          a.fillStyle = "#ffcc00";
          if (this._highlight_input) {
            a.beginPath();
            var h = this._highlight_input_slot.shape;
            h === g.ARROW_SHAPE ? (a.moveTo(this._highlight_input[0] + 8, this._highlight_input[1] + 0.5), a.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] + 6 + 0.5), a.lineTo(this._highlight_input[0] - 4, this._highlight_input[1] - 6 + 0.5), a.closePath()) : a.arc(this._highlight_input[0], this._highlight_input[1], 6, 0, 2 * Math.PI);
            a.fill();
          }
          this._highlight_output && (a.beginPath(), h === g.ARROW_SHAPE ? (a.moveTo(this._highlight_output[0] + 8, this._highlight_output[1] + 0.5), a.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] + 6 + 0.5), a.lineTo(this._highlight_output[0] - 4, this._highlight_output[1] - 6 + 0.5), a.closePath()) : a.arc(this._highlight_output[0], this._highlight_output[1], 6, 0, 2 * Math.PI), a.fill());
        }
        this.dragging_rectangle && (a.strokeStyle = "#FFF", a.strokeRect(this.dragging_rectangle[0], this.dragging_rectangle[1], this.dragging_rectangle[2], this.dragging_rectangle[3]));
        if (this.over_link_center && this.render_link_tooltip) {
          this.drawLinkTooltip(a, this.over_link_center);
        } else {
          if (this.onDrawLinkTooltip) {
            this.onDrawLinkTooltip(a, null);
          }
        }
        if (this.onDrawForeground) {
          this.onDrawForeground(a, this.visible_rect);
        }
        a.restore();
      }
      this._graph_stack && this._graph_stack.length && this.drawSubgraphPanel(a);
      if (this.onDrawOverlay) {
        this.onDrawOverlay(a);
      }
      c && a.restore();
      a.finish2D && a.finish2D();
    }
  };
  n.prototype.drawSubgraphPanel = function(a) {
    var b = this.graph, c = b._subgraph_node;
    c ? (this.drawSubgraphPanelLeft(b, c, a), this.drawSubgraphPanelRight(b, c, a)) : console.warn("subgraph without subnode");
  };
  n.prototype.drawSubgraphPanelLeft = function(a, b, c) {
    var e = b.inputs ? b.inputs.length : 0, d = Math.floor(1.6 * g.NODE_SLOT_HEIGHT);
    c.fillStyle = "#111";
    c.globalAlpha = 0.8;
    c.beginPath();
    c.roundRect(10, 10, 200, (e + 1) * d + 50, [8]);
    c.fill();
    c.globalAlpha = 1;
    c.fillStyle = "#888";
    c.font = "14px Arial";
    c.textAlign = "left";
    c.fillText("Graph Inputs", 20, 34);
    if (this.drawButton(180, 20, 20, 20, "X", "#151515")) {
      this.closeSubgraph();
    } else {
      e = 50;
      c.font = "14px Arial";
      if (b.inputs) {
        for (var f = 0; f < b.inputs.length; ++f) {
          var h = b.inputs[f];
          if (!h.not_subgraph_input) {
            if (this.drawButton(20, e + 2, 180, d - 2)) {
              var k = b.constructor.input_node_type || "graph/input";
              this.graph.beforeChange();
              var q = g.createNode(k);
              q ? (a.add(q), this.block_click = !1, this.last_click_position = null, this.selectNodes([q]), this.node_dragged = q, this.dragging_canvas = !1, q.setProperty("name", h.name), q.setProperty("type", h.type), this.node_dragged.pos[0] = this.graph_mouse[0] - 5, this.node_dragged.pos[1] = this.graph_mouse[1] - 5, this.graph.afterChange()) : console.error("graph input node not found:", k);
            }
            c.fillStyle = "#9C9";
            c.beginPath();
            c.arc(184, e + 0.5 * d, 5, 0, 2 * Math.PI);
            c.fill();
            c.fillStyle = "#AAA";
            c.fillText(h.name, 30, e + 0.75 * d);
            c.fillStyle = "#777";
            c.fillText(h.type, 130, e + 0.75 * d);
            e += d;
          }
        }
      }
      this.drawButton(20, e + 2, 180, d - 2, "+", "#151515", "#222") && this.showSubgraphPropertiesDialog(b);
    }
  };
  n.prototype.drawSubgraphPanelRight = function(a, b, c) {
    var e = b.outputs ? b.outputs.length : 0, d = this.bgcanvas.width, f = Math.floor(1.6 * g.NODE_SLOT_HEIGHT);
    c.fillStyle = "#111";
    c.globalAlpha = 0.8;
    c.beginPath();
    c.roundRect(d - 200 - 10, 10, 200, (e + 1) * f + 50, [8]);
    c.fill();
    c.globalAlpha = 1;
    c.fillStyle = "#888";
    c.font = "14px Arial";
    c.textAlign = "left";
    e = c.measureText("Graph Outputs").width;
    c.fillText("Graph Outputs", d - e - 20, 34);
    if (this.drawButton(d - 200, 20, 20, 20, "X", "#151515")) {
      this.closeSubgraph();
    } else {
      e = 50;
      c.font = "14px Arial";
      if (b.outputs) {
        for (var h = 0; h < b.outputs.length; ++h) {
          var k = b.outputs[h];
          if (!k.not_subgraph_input) {
            if (this.drawButton(d - 200, e + 2, 180, f - 2)) {
              var q = b.constructor.output_node_type || "graph/output";
              this.graph.beforeChange();
              var r = g.createNode(q);
              r ? (a.add(r), this.block_click = !1, this.last_click_position = null, this.selectNodes([r]), this.node_dragged = r, this.dragging_canvas = !1, r.setProperty("name", k.name), r.setProperty("type", k.type), this.node_dragged.pos[0] = this.graph_mouse[0] - 5, this.node_dragged.pos[1] = this.graph_mouse[1] - 5, this.graph.afterChange()) : console.error("graph input node not found:", q);
            }
            c.fillStyle = "#9C9";
            c.beginPath();
            c.arc(d - 200 + 16, e + 0.5 * f, 5, 0, 2 * Math.PI);
            c.fill();
            c.fillStyle = "#AAA";
            c.fillText(k.name, d - 200 + 30, e + 0.75 * f);
            c.fillStyle = "#777";
            c.fillText(k.type, d - 200 + 130, e + 0.75 * f);
            e += f;
          }
        }
      }
      this.drawButton(d - 200, e + 2, 180, f - 2, "+", "#151515", "#222") && this.showSubgraphPropertiesDialogRight(b);
    }
  };
  n.prototype.drawButton = function(a, b, c, e, d, f, h, k) {
    var q = this.ctx;
    f = f || g.NODE_DEFAULT_COLOR;
    h = h || "#555";
    k = k || g.NODE_TEXT_COLOR;
    var r = b + g.NODE_TITLE_HEIGHT + 2, u = this.mouse, p = g.isInsideRectangle(u[0], u[1], a, r, c, e);
    r = (u = this.last_click_position) && g.isInsideRectangle(u[0], u[1], a, r, c, e);
    q.fillStyle = p ? h : f;
    r && (q.fillStyle = "#AAA");
    q.beginPath();
    q.roundRect(a, b, c, e, [4]);
    q.fill();
    null != d && d.constructor == String && (q.fillStyle = k, q.textAlign = "center", q.font = (0.65 * e | 0) + "px Arial", q.fillText(d, a + 0.5 * c, b + 0.75 * e), q.textAlign = "left");
    a = r && !this.block_click;
    r && this.blockClick();
    return a;
  };
  n.prototype.isAreaClicked = function(a, b, c, e, d) {
    var f = this.mouse;
    g.isInsideRectangle(f[0], f[1], a, b, c, e);
    b = (a = (f = this.last_click_position) && g.isInsideRectangle(f[0], f[1], a, b, c, e)) && !this.block_click;
    a && d && this.blockClick();
    return b;
  };
  n.prototype.renderInfo = function(a, b, c) {
    b = b || 10;
    c = c || this.canvas.height - 80;
    a.save();
    a.translate(b, c);
    a.font = "10px Arial";
    a.fillStyle = "#888";
    a.textAlign = "left";
    this.graph ? (a.fillText("T: " + this.graph.globaltime.toFixed(2) + "s", 5, 13), a.fillText("I: " + this.graph.iteration, 5, 26), a.fillText("N: " + this.graph._nodes.length + " [" + this.visible_nodes.length + "]", 5, 39), a.fillText("V: " + this.graph._version, 5, 52), a.fillText("FPS:" + this.fps.toFixed(2), 5, 65)) : a.fillText("No graph selected", 5, 13);
    a.restore();
  };
  n.prototype.drawBackCanvas = function() {
    var a = this.bgcanvas;
    if (a.width != this.canvas.width || a.height != this.canvas.height) {
      a.width = this.canvas.width, a.height = this.canvas.height;
    }
    this.bgctx || (this.bgctx = this.bgcanvas.getContext("2d"));
    var b = this.bgctx;
    b.start && b.start();
    var c = this.viewport || [0, 0, b.canvas.width, b.canvas.height];
    this.clear_background && b.clearRect(c[0], c[1], c[2], c[3]);
    if (this._graph_stack && this._graph_stack.length) {
      b.save();
      c = this.graph._subgraph_node;
      b.strokeStyle = c.bgcolor;
      b.lineWidth = 10;
      b.strokeRect(1, 1, a.width - 2, a.height - 2);
      b.lineWidth = 1;
      b.font = "40px Arial";
      b.textAlign = "center";
      b.fillStyle = c.bgcolor || "#AAA";
      for (var e = "", d = 1; d < this._graph_stack.length; ++d) {
        e += this._graph_stack[d]._subgraph_node.getTitle() + " >> ";
      }
      b.fillText(e + c.getTitle(), 0.5 * a.width, 40);
      b.restore();
    }
    c = !1;
    this.onRenderBackground && (c = this.onRenderBackground(a, b));
    this.viewport || (b.restore(), b.setTransform(1, 0, 0, 1, 0, 0));
    this.visible_links.length = 0;
    if (this.graph) {
      b.save();
      this.ds.toCanvasContext(b);
      if (this.background_image && 0.5 < this.ds.scale && !c) {
        b.globalAlpha = this.zoom_modify_alpha ? (1.0 - 0.5 / this.ds.scale) * this.editor_alpha : this.editor_alpha;
        b.imageSmoothingEnabled = b.imageSmoothingEnabled = !1;
        if (!this._bg_img || this._bg_img.name != this.background_image) {
          this._bg_img = new Image;
          this._bg_img.name = this.background_image;
          this._bg_img.src = this.background_image;
          var f = this;
          this._bg_img.onload = function() {
            f.draw(!0, !0);
          };
        }
        c = null;
        null == this._pattern && 0 < this._bg_img.width ? (c = b.createPattern(this._bg_img, "repeat"), this._pattern_img = this._bg_img, this._pattern = c) : c = this._pattern;
        c && (b.save(), b.filter = "brightness(120%)", b.fillStyle = c, b.fillRect(this.visible_area[0], this.visible_area[1], this.visible_area[2], this.visible_area[3]), b.restore(), b.fillStyle = "transparent");
        b.globalAlpha = 1.0;
        b.imageSmoothingEnabled = b.imageSmoothingEnabled = !0;
      }
      this.graph._groups.length && !this.live_mode && this.drawGroups(a, b);
      if (this.onDrawBackground) {
        this.onDrawBackground(b, this.visible_area);
      }
      this.onBackgroundRender && (console.error("WARNING! onBackgroundRender deprecated, now is named onDrawBackground "), this.onBackgroundRender = null);
      this.render_canvas_border && (b.strokeStyle = "#235", b.strokeRect(0, 0, a.width, a.height));
      this.render_connections_shadows ? (b.shadowColor = "#000", b.shadowOffsetX = 0, b.shadowOffsetY = 0, b.shadowBlur = 6) : b.shadowColor = "rgba(0,0,0,0)";
      this.live_mode || this.drawConnections(b);
      b.shadowColor = "rgba(0,0,0,0)";
      b.restore();
    }
    b.finish && b.finish();
    this.dirty_bgcanvas = !1;
    this.dirty_canvas = !0;
  };
  var E = new Float32Array(2);
  n.prototype.drawNode = function(a, b) {
    this.current_node = a;
    var c = a.color || a.constructor.color || g.NODE_DEFAULT_COLOR, e = a.bgcolor || a.constructor.bgcolor || g.NODE_DEFAULT_BGCOLOR, d = 0.6 > this.ds.scale;
    if (this.live_mode) {
      if (!a.flags.collapsed && (b.shadowColor = "transparent", a.onDrawForeground)) {
        a.onDrawForeground(b, this, this.canvas);
      }
    } else {
      var f = this.editor_alpha;
      b.globalAlpha = f;
      this.render_shadows && !d ? (b.shadowColor = g.DEFAULT_SHADOW_COLOR, b.shadowOffsetX = 0 * this.ds.scale, b.shadowOffsetY = 3 * this.ds.scale, b.shadowBlur = 6 * this.ds.scale) : b.shadowColor = "transparent";
      if (!a.flags.collapsed || !a.onDrawCollapsed || 1 != a.onDrawCollapsed(b, this)) {
        var h = a._shape || g.BOX_SHAPE;
        E.set(a.size);
        var k = a.horizontal;
        if (a.flags.collapsed) {
          b.font = this.inner_text_font;
          var q = a.getTitle ? a.getTitle() : a.title;
          null != q && (a._collapsed_width = Math.min(a.size[0], b.measureText(q).width + 2 * g.NODE_TITLE_HEIGHT), E[0] = a._collapsed_width, E[1] = 0);
        }
        a.clip_area && (b.save(), b.beginPath(), h == g.BOX_SHAPE ? b.rect(0, 0, E[0], E[1]) : h == g.ROUND_SHAPE ? b.roundRect(0, 0, E[0], E[1], [10]) : h == g.CIRCLE_SHAPE && b.arc(0.5 * E[0], 0.5 * E[1], 0.5 * E[0], 0, 2 * Math.PI), b.clip());
        a.has_errors && (e = "red");
        this.drawNodeShape(a, b, E, c, e, a.is_selected, a.mouseOver);
        b.shadowColor = "transparent";
        if (a.onDrawForeground) {
          a.onDrawForeground(b, this, this.canvas);
        }
        b.textAlign = k ? "center" : "left";
        b.font = this.inner_text_font;
        e = !d;
        var r = this.connecting_output;
        h = this.connecting_input;
        b.lineWidth = 1;
        q = 0;
        var u = new Float32Array(2);
        if (!a.flags.collapsed) {
          if (a.inputs) {
            for (c = 0; c < a.inputs.length; c++) {
              var p = a.inputs[c];
              if (!1 !== p.visible || g.draw_invisible_connections) {
                var n = p.type, x = p.shape;
                b.globalAlpha = f;
                this.connecting_output && !g.isValidConnection(p.type, r.type) && (b.globalAlpha = 0.4 * f);
                b.fillStyle = null != p.link ? p.color_on || this.default_connection_color_byType[n] || this.default_connection_color.input_on : p.color_off || this.default_connection_color.input_off;
                var v = a.getConnectionPos(!0, c, u);
                v[0] -= a.pos[0];
                v[1] -= a.pos[1];
                q < v[1] + 0.5 * g.NODE_SLOT_HEIGHT && (q = v[1] + 0.5 * g.NODE_SLOT_HEIGHT);
                b.beginPath();
                "array" == n && (x = g.GRID_SHAPE);
                p.type === g.EVENT || p.shape === g.BOX_SHAPE ? k ? b.rect(v[0] - 5 + 0.5, v[1] - 8 + 0.5, 10, 14) : b.rect(v[0] - 6 + 0.5, v[1] - 5 + 0.5, 14, 10) : x === g.ARROW_SHAPE ? (b.moveTo(v[0] + 8, v[1] + 0.5), b.lineTo(v[0] - 4, v[1] + 6 + 0.5), b.lineTo(v[0] - 4, v[1] - 6 + 0.5), b.closePath()) : x === g.GRID_SHAPE ? (b.rect(v[0] - 4, v[1] - 4, 2, 2), b.rect(v[0] - 1, v[1] - 4, 2, 2), b.rect(v[0] + 2, v[1] - 4, 2, 2), b.rect(v[0] - 4, v[1] - 1, 2, 2), b.rect(v[0] - 1, v[1] - 1, 2, 2), 
                b.rect(v[0] + 2, v[1] - 1, 2, 2), b.rect(v[0] - 4, v[1] + 2, 2, 2), b.rect(v[0] - 1, v[1] + 2, 2, 2), b.rect(v[0] + 2, v[1] + 2, 2, 2)) : d ? b.rect(v[0] - 4, v[1] - 4, 8, 8) : b.arc(v[0], v[1], 4, 0, 2 * Math.PI);
                b.strokeStyle = b.fillStyle;
                b.stroke();
                p.link && b.fill();
                e && (n = null != p.label ? p.label : p.name) && (b.fillStyle = g.NODE_TEXT_COLOR, k || p.dir == g.UP ? b.fillText(n, v[0], v[1] - 10) : b.fillText(n, v[0] + 10, v[1] + 5));
              }
            }
          }
          b.textAlign = k ? "center" : "right";
          b.strokeStyle = "black";
          if (a.outputs) {
            for (c = 0; c < a.outputs.length; c++) {
              if (p = a.outputs[c], !1 !== p.visible || g.draw_invisible_connections) {
                if (n = p.type, x = p.shape, this.connecting_input && !g.isValidConnection(n, h.type) && (b.globalAlpha = 0.4 * f), v = a.getConnectionPos(!1, c, u), v[0] -= a.pos[0], v[1] -= a.pos[1], q < v[1] + 0.5 * g.NODE_SLOT_HEIGHT && (q = v[1] + 0.5 * g.NODE_SLOT_HEIGHT), b.fillStyle = p.links && p.links.length ? p.color_on || this.default_connection_color_byType[n] || this.default_connection_color.output_on : p.color_off || this.default_connection_color_byTypeOff[n] || this.default_connection_color_byType[n] || 
                this.default_connection_color.output_off, b.beginPath(), "array" == n && (x = g.GRID_SHAPE), r = !0, n === g.EVENT || x === g.BOX_SHAPE ? k ? b.rect(v[0] - 5 + 0.5, v[1] - 8 + 0.5, 10, 14) : b.rect(v[0] - 6 + 0.5, v[1] - 5 + 0.5, 14, 10) : x === g.ARROW_SHAPE ? (b.moveTo(v[0] + 8, v[1] + 0.5), b.lineTo(v[0] - 4, v[1] + 6 + 0.5), b.lineTo(v[0] - 4, v[1] - 6 + 0.5), b.closePath()) : x === g.GRID_SHAPE ? (b.rect(v[0] - 4, v[1] - 4, 2, 2), b.rect(v[0] - 1, v[1] - 4, 2, 2), b.rect(v[0] + 
                2, v[1] - 4, 2, 2), b.rect(v[0] - 4, v[1] - 1, 2, 2), b.rect(v[0] - 1, v[1] - 1, 2, 2), b.rect(v[0] + 2, v[1] - 1, 2, 2), b.rect(v[0] - 4, v[1] + 2, 2, 2), b.rect(v[0] - 1, v[1] + 2, 2, 2), b.rect(v[0] + 2, v[1] + 2, 2, 2), r = !1) : d ? b.rect(v[0] - 4, v[1] - 4, 8, 8) : b.arc(v[0], v[1], 4, 0, 2 * Math.PI), b.strokeStyle = b.fillStyle, b.stroke(), p.links && p.links.length && b.fill(), !d && r && b.stroke(), e && (n = null != p.label ? p.label : p.name)) {
                  b.fillStyle = g.NODE_TEXT_COLOR, k || p.dir == g.DOWN ? b.fillText(n, v[0], v[1] - 8) : b.fillText(n, v[0] - 10, v[1] + 4);
                }
              }
            }
          }
          b.textAlign = "left";
          b.globalAlpha = 1;
          if (a.widgets) {
            p = q;
            if (k || a.widgets_up) {
              p = 2;
            }
            null != a.widgets_start_y && (p = a.widgets_start_y);
            this.drawNodeWidgets(a, p, b, this.node_widget && this.node_widget[0] == a ? this.node_widget[1] : null);
          }
        } else {
          if (this.render_collapsed_slots) {
            d = f = null;
            if (a.inputs) {
              for (c = 0; c < a.inputs.length; c++) {
                if (p = a.inputs[c], null != p.link) {
                  f = p;
                  break;
                }
              }
            }
            if (a.outputs) {
              for (c = 0; c < a.outputs.length; c++) {
                p = a.outputs[c], p.links && p.links.length && (d = p);
              }
            }
            f && (f = 0, c = -0.5 * g.NODE_TITLE_HEIGHT, k && (f = 0.5 * a._collapsed_width, c = -g.NODE_TITLE_HEIGHT), b.fillStyle = "#686", b.beginPath(), p.type === g.EVENT || p.shape === g.BOX_SHAPE ? b.rect(f - 7 + 0.5, c - 4, 14, 8) : p.shape === g.ARROW_SHAPE ? (b.moveTo(f + 8, c), b.lineTo(f + -4, c - 4), b.lineTo(f + -4, c + 4), b.closePath()) : b.arc(f, c, 4, 0, 2 * Math.PI), b.fill());
            d && (f = a._collapsed_width, c = -0.5 * g.NODE_TITLE_HEIGHT, k && (f = 0.5 * a._collapsed_width, c = 0), b.fillStyle = "#686", b.strokeStyle = "black", b.beginPath(), p.type === g.EVENT || p.shape === g.BOX_SHAPE ? b.rect(f - 7 + 0.5, c - 4, 14, 8) : p.shape === g.ARROW_SHAPE ? (b.moveTo(f + 6, c), b.lineTo(f - 6, c - 4), b.lineTo(f - 6, c + 4), b.closePath()) : b.arc(f, c, 4, 0, 2 * Math.PI), b.fill());
          }
        }
        a.clip_area && b.restore();
        b.globalAlpha = 1.0;
      }
    }
  };
  n.prototype.drawLinkTooltip = function(a, b) {
    var c = b._pos;
    a.fillStyle = "black";
    a.beginPath();
    a.arc(c[0], c[1], 3, 0, 2 * Math.PI);
    a.fill();
    if (null != b.data && (!this.onDrawLinkTooltip || 1 != this.onDrawLinkTooltip(a, b, this)) && (b = b.data, b = b.constructor === Number ? b.toFixed(2) : b.constructor === String ? '"' + b + '"' : b.constructor === Boolean ? String(b) : b.toToolTip ? b.toToolTip() : "[" + b.constructor.name + "]", null != b)) {
      b = b.substr(0, 30);
      a.font = "14px Courier New";
      var e = a.measureText(b).width + 20;
      a.shadowColor = "black";
      a.shadowOffsetX = 2;
      a.shadowOffsetY = 2;
      a.shadowBlur = 3;
      a.fillStyle = "#454";
      a.beginPath();
      a.roundRect(c[0] - 0.5 * e, c[1] - 15 - 24, e, 24, [3]);
      a.moveTo(c[0] - 10, c[1] - 15);
      a.lineTo(c[0] + 10, c[1] - 15);
      a.lineTo(c[0], c[1] - 5);
      a.fill();
      a.shadowColor = "transparent";
      a.textAlign = "center";
      a.fillStyle = "#CEC";
      a.fillText(b, c[0], c[1] - 15 - 24 * 0.3);
    }
  };
  var z = new Float32Array(4);
  n.prototype.drawNodeShape = function(a, b, c, e, d, f, h) {
    b.strokeStyle = e;
    b.fillStyle = d;
    d = g.NODE_TITLE_HEIGHT;
    var k = 0.5 > this.ds.scale, q = a._shape || a.constructor.shape || g.ROUND_SHAPE, r = a.constructor.title_mode, u = !0;
    r == g.TRANSPARENT_TITLE || r == g.NO_TITLE ? u = !1 : r == g.AUTOHIDE_TITLE && h && (u = !0);
    z[0] = -1;
    z[1] = u ? -d - 1 : 0;
    z[2] = c[0] + 3;
    z[3] = u ? c[1] + d + 2 : c[1];
    h = b.globalAlpha;
    b.beginPath();
    q == g.BOX_SHAPE || k ? b.fillRect(z[0], z[1], z[2], z[3]) : q == g.ROUND_SHAPE || q == g.CARD_SHAPE ? b.roundRect(z[0], z[1], z[2], z[3], q == g.CARD_SHAPE ? [this.round_radius, this.round_radius, 0, 0] : [this.round_radius]) : q == g.CIRCLE_SHAPE && b.arc(0.5 * c[0], 0.5 * c[1], 0.5 * c[0], 0, 2 * Math.PI);
    b.fill();
    b.shadowColor = "transparent";
    if (a.onDrawBackground) {
      a.onDrawBackground(b, this, this.canvas, this.graph_mouse);
    }
    if (u || r == g.TRANSPARENT_TITLE) {
      if (a.onDrawTitleBar) {
        a.onDrawTitleBar(b, d, c, this.ds.scale, e);
      } else {
        if (r != g.TRANSPARENT_TITLE && (a.constructor.title_color || this.render_title_colored)) {
          u = a.constructor.title_color || e;
          a.flags.collapsed && (b.shadowColor = g.DEFAULT_SHADOW_COLOR);
          if (this.use_gradients) {
            var p = n.gradients[u];
            p || (p = n.gradients[u] = b.createLinearGradient(0, 0, 400, 0), p.addColorStop(0, u), p.addColorStop(1, "#000"));
            b.fillStyle = p;
          } else {
            b.fillStyle = u;
          }
          b.beginPath();
          q == g.BOX_SHAPE || k ? b.rect(0, -d, c[0] + 1, d) : (q == g.ROUND_SHAPE || q == g.CARD_SHAPE) && b.roundRect(0, -d, c[0] + 1, d, a.flags.collapsed ? [this.round_radius] : [this.round_radius, this.round_radius, 0, 0]);
          b.fill();
          b.shadowColor = "transparent";
        }
      }
      u = !1;
      g.node_box_coloured_by_mode && g.NODE_MODES_COLORS[a.mode] && (u = g.NODE_MODES_COLORS[a.mode]);
      g.node_box_coloured_when_on && (u = a.action_triggered ? "#FFF" : a.execute_triggered ? "#AAA" : u);
      if (a.onDrawTitleBox) {
        a.onDrawTitleBox(b, d, c, this.ds.scale);
      } else {
        q == g.ROUND_SHAPE || q == g.CIRCLE_SHAPE || q == g.CARD_SHAPE ? (k && (b.fillStyle = "black", b.beginPath(), b.arc(0.5 * d, -0.5 * d, 6, 0, 2 * Math.PI), b.fill()), b.fillStyle = a.boxcolor || u || g.NODE_DEFAULT_BOXCOLOR, k ? b.fillRect(0.5 * d - 5, -0.5 * d - 5, 10, 10) : (b.beginPath(), b.arc(0.5 * d, -0.5 * d, 5, 0, 2 * Math.PI), b.fill())) : (k && (b.fillStyle = "black", b.fillRect(0.5 * (d - 10) - 1, -0.5 * (d + 10) - 1, 12, 12)), b.fillStyle = a.boxcolor || u || g.NODE_DEFAULT_BOXCOLOR, 
        b.fillRect(0.5 * (d - 10), -0.5 * (d + 10), 10, 10));
      }
      b.globalAlpha = h;
      if (a.onDrawTitleText) {
        a.onDrawTitleText(b, d, c, this.ds.scale, this.title_text_font, f);
      } else {
        !k && (b.font = this.title_text_font, h = String(a.getTitle())) && (b.shadowBlur = this.title_shadow_blur, b.shadowOffsetX = this.title_shadow_offset_x, b.shadowOffsetY = this.title_shadow_offset_y, b.shadowColor = this.title_shadow_color, b.fillStyle = f ? g.NODE_SELECTED_TITLE_COLOR : a.constructor.title_text_color || this.node_title_color, a.flags.collapsed ? (b.textAlign = "left", b.measureText(h), b.fillText(h.substr(0, 20), d, g.NODE_TITLE_TEXT_Y - d), b.textAlign = "left") : (b.textAlign = 
        "left", b.fillText(h, a.title_offset_x || a.constructor.title_offset_x || d, g.NODE_TITLE_TEXT_Y - d)));
      }
      a.flags.collapsed || !a.subgraph || a.skip_subgraph_button || (h = g.NODE_TITLE_HEIGHT, u = a.size[0] - h, p = g.isInsideRectangle(this.graph_mouse[0] - a.pos[0], this.graph_mouse[1] - a.pos[1], u + 2, -h + 2, h - 4, h - 4), b.fillStyle = p ? "#888" : "#555", q == g.BOX_SHAPE || k ? b.fillRect(u + 2, -h + 2, h - 4, h - 4) : (b.beginPath(), b.roundRect(u + 2, -h + 2, h - 4, h - 4, [4]), b.fill()), b.fillStyle = "#333", b.beginPath(), b.moveTo(u + 0.2 * h, 0.6 * -h), b.lineTo(u + 0.8 * h, 0.6 * 
      -h), b.lineTo(u + 0.5 * h, 0.3 * -h), b.fill());
      if (a.onDrawTitle) {
        a.onDrawTitle(b);
      }
    }
    if (f) {
      if (a.onBounding) {
        a.onBounding(z);
      }
      r == g.TRANSPARENT_TITLE && (z[1] -= d, z[3] += d);
      b.lineWidth = 1;
      b.globalAlpha = 0.8;
      b.beginPath();
      q == g.BOX_SHAPE ? b.rect(-6 + z[0], -6 + z[1], 12 + z[2], 12 + z[3]) : q == g.ROUND_SHAPE || q == g.CARD_SHAPE && a.flags.collapsed ? b.roundRect(-6 + z[0], -6 + z[1], 12 + z[2], 12 + z[3], [2 * this.round_radius]) : q == g.CARD_SHAPE ? b.roundRect(-6 + z[0], -6 + z[1], 12 + z[2], 12 + z[3], [2 * this.round_radius, 2, 2 * this.round_radius, 2]) : q == g.CIRCLE_SHAPE && b.arc(0.5 * c[0], 0.5 * c[1], 0.5 * c[0] + 6, 0, 2 * Math.PI);
      b.strokeStyle = g.NODE_BOX_OUTLINE_COLOR;
      b.stroke();
      b.strokeStyle = e;
      b.globalAlpha = 1;
    }
    0 < a.execute_triggered && a.execute_triggered--;
    0 < a.action_triggered && a.action_triggered--;
  };
  var I = new Float32Array(4), C = new Float32Array(4), K = new Float32Array(2), L = new Float32Array(2);
  n.prototype.drawConnections = function(a) {
    var b = g.getTime(), c = this.visible_area;
    I[0] = c[0] - 20;
    I[1] = c[1] - 20;
    I[2] = c[2] + 40;
    I[3] = c[3] + 40;
    a.lineWidth = this.connections_width;
    a.fillStyle = "#AAA";
    a.strokeStyle = "#AAA";
    a.globalAlpha = this.editor_alpha;
    c = this.graph._nodes;
    for (var e = 0, d = c.length; e < d; ++e) {
      var f = c[e];
      if (f.inputs && f.inputs.length) {
        for (var h = 0; h < f.inputs.length; ++h) {
          var k = f.inputs[h];
          if (k && null != k.link && (k = this.graph.links[k.link])) {
            var q = this.graph.getNodeById(k.origin_id);
            if (null != q) {
              var r = k.origin_slot;
              var u = -1 == r ? [q.pos[0] + 10, q.pos[1] + 10] : q.getConnectionPos(!1, r, K);
              var p = f.getConnectionPos(!0, h, L);
              C[0] = u[0];
              C[1] = u[1];
              C[2] = p[0] - u[0];
              C[3] = p[1] - u[1];
              0 > C[2] && (C[0] += C[2], C[2] = Math.abs(C[2]));
              0 > C[3] && (C[1] += C[3], C[3] = Math.abs(C[3]));
              if (H(C, I)) {
                var n = q.outputs[r], x = f.inputs[h];
                n && x && (r = !1 === n.visible || !1 === x.visible, !r || g.draw_invisible_connections) && (q = n.dir || (q.horizontal ? g.DOWN : g.RIGHT), x = x.dir || (f.horizontal ? g.UP : g.LEFT), this.renderLink(a, u, p, k, !1, 0, r ? "red" : null, q, x), k && k._last_time && 1000 > b - k._last_time && (r = 2.0 - 0.002 * (b - k._last_time), n = a.globalAlpha, a.globalAlpha = n * r, this.renderLink(a, u, p, k, !0, r, "white", q, x), a.globalAlpha = n));
              }
            }
          }
        }
      }
    }
    a.globalAlpha = 1;
  };
  n.prototype.renderLink = function(a, b, c, e, d, f, h, k, q, r) {
    e && this.visible_links.push(e);
    !h && e && (h = e.color || n.link_type_colors[e.type]);
    h || (h = this.default_link_color);
    null != e && this.highlighted_links[e.id] && (h = "#FFF");
    k = k || g.RIGHT;
    q = q || g.LEFT;
    var u = G(b, c);
    this.render_connections_border && 0.6 < this.ds.scale && (a.lineWidth = this.connections_width + 4);
    a.lineJoin = "round";
    r = r || 1;
    1 < r && (a.lineWidth = 0.5);
    a.beginPath();
    for (var p = 0; p < r; p += 1) {
      var x = 5 * (p - 0.5 * (r - 1));
      if (this.links_render_mode == g.SPLINE_LINK) {
        a.moveTo(b[0], b[1] + x);
        var l = 0, v = 0, m = 0, t = 0;
        switch(k) {
          case g.LEFT:
            l = -0.25 * u;
            break;
          case g.RIGHT:
            l = 0.25 * u;
            break;
          case g.UP:
            v = -0.25 * u;
            break;
          case g.DOWN:
            v = 0.25 * u;
        }
        switch(q) {
          case g.LEFT:
            m = -0.25 * u;
            break;
          case g.RIGHT:
            m = 0.25 * u;
            break;
          case g.UP:
            t = -0.25 * u;
            break;
          case g.DOWN:
            t = 0.25 * u;
        }
        a.bezierCurveTo(b[0] + l, b[1] + v + x, c[0] + m, c[1] + t + x, c[0], c[1] + x);
      } else {
        if (this.links_render_mode == g.LINEAR_LINK) {
          a.moveTo(b[0], b[1] + x);
          t = m = v = l = 0;
          switch(k) {
            case g.LEFT:
              l = -1;
              break;
            case g.RIGHT:
              l = 1;
              break;
            case g.UP:
              v = -1;
              break;
            case g.DOWN:
              v = 1;
          }
          switch(q) {
            case g.LEFT:
              m = -1;
              break;
            case g.RIGHT:
              m = 1;
              break;
            case g.UP:
              t = -1;
              break;
            case g.DOWN:
              t = 1;
          }
          a.lineTo(b[0] + 15 * l, b[1] + 15 * v + x);
          a.lineTo(c[0] + 15 * m, c[1] + 15 * t + x);
          a.lineTo(c[0], c[1] + x);
        } else {
          if (this.links_render_mode == g.STRAIGHT_LINK) {
            a.moveTo(b[0], b[1]), x = b[0], l = b[1], v = c[0], m = c[1], k == g.RIGHT ? x += 10 : l += 10, q == g.LEFT ? v -= 10 : m -= 10, a.lineTo(x, l), a.lineTo(0.5 * (x + v), l), a.lineTo(0.5 * (x + v), m), a.lineTo(v, m), a.lineTo(c[0], c[1]);
          } else {
            return;
          }
        }
      }
    }
    this.render_connections_border && 0.6 < this.ds.scale && !d && (a.strokeStyle = "rgba(0,0,0,0.5)", a.stroke());
    a.lineWidth = this.connections_width;
    a.fillStyle = a.strokeStyle = h;
    a.shadowBlur = 3 * this.ds.scale;
    a.shadowColor = "black";
    a.shadowOffsetX = 0;
    a.stroke();
    a.shadowBlur = 0;
    a.lineWidth = 1;
    a.fillStyle = a.strokeStyle = w(a.fillStyle, 1, 1.5);
    a.stroke();
    d = this.computeConnectionPoint(b, c, 0.5, k, q);
    e && e._pos && (e._pos[0] = d[0], e._pos[1] = d[1]);
    0.6 <= this.ds.scale && this.highquality_render && q != g.CENTER && (this.render_connection_arrows && (p = this.computeConnectionPoint(b, c, 0.25, k, q), u = this.computeConnectionPoint(b, c, 0.26, k, q), e = this.computeConnectionPoint(b, c, 0.75, k, q), r = this.computeConnectionPoint(b, c, 0.76, k, q), this.render_curved_connections ? (u = -Math.atan2(u[0] - p[0], u[1] - p[1]), r = -Math.atan2(r[0] - e[0], r[1] - e[1])) : r = u = c[1] > b[1] ? 0 : Math.PI, a.save(), a.translate(p[0], p[1]), 
    a.rotate(u), a.beginPath(), a.moveTo(-5, -3), a.lineTo(0, 7), a.lineTo(5, -3), a.fill(), a.restore(), a.save(), a.translate(e[0], e[1]), a.rotate(r), a.beginPath(), a.moveTo(-5, -3), a.lineTo(0, 7), a.lineTo(5, -3), a.fill(), a.restore()), this.render_link_center && (a.beginPath(), a.arc(d[0], d[1], 5, 0, 2 * Math.PI), a.fill()));
    if (f) {
      for (a.fillStyle = h, p = 0; 5 > p; ++p) {
        f = (0.001 * g.getTime() + 0.2 * p) % 1, d = this.computeConnectionPoint(b, c, f, k, q), a.beginPath(), a.arc(d[0], d[1], 5, 0, 2 * Math.PI), a.fill();
      }
    }
  };
  n.prototype.computeConnectionPoint = function(a, b, c, e, d) {
    e = e || g.RIGHT;
    d = d || g.LEFT;
    var f = G(a, b), h = [a[0], a[1]], k = [b[0], b[1]];
    switch(e) {
      case g.LEFT:
        h[0] += -0.25 * f;
        break;
      case g.RIGHT:
        h[0] += 0.25 * f;
        break;
      case g.UP:
        h[1] += -0.25 * f;
        break;
      case g.DOWN:
        h[1] += 0.25 * f;
    }
    switch(d) {
      case g.LEFT:
        k[0] += -0.25 * f;
        break;
      case g.RIGHT:
        k[0] += 0.25 * f;
        break;
      case g.UP:
        k[1] += -0.25 * f;
        break;
      case g.DOWN:
        k[1] += 0.25 * f;
    }
    e = (1 - c) * (1 - c) * (1 - c);
    d = 3 * (1 - c) * (1 - c) * c;
    f = 3 * (1 - c) * c * c;
    c *= c * c;
    return [e * a[0] + d * h[0] + f * k[0] + c * b[0], e * a[1] + d * h[1] + f * k[1] + c * b[1]];
  };
  n.prototype.drawExecutionOrder = function(a) {
    a.shadowColor = "transparent";
    a.globalAlpha = 0.25;
    a.textAlign = "center";
    a.strokeStyle = "white";
    a.globalAlpha = 0.75;
    for (var b = this.visible_nodes, c = 0; c < b.length; ++c) {
      var e = b[c];
      a.fillStyle = "black";
      a.fillRect(e.pos[0] - g.NODE_TITLE_HEIGHT, e.pos[1] - g.NODE_TITLE_HEIGHT, g.NODE_TITLE_HEIGHT, g.NODE_TITLE_HEIGHT);
      0 == e.order && a.strokeRect(e.pos[0] - g.NODE_TITLE_HEIGHT + 0.5, e.pos[1] - g.NODE_TITLE_HEIGHT + 0.5, g.NODE_TITLE_HEIGHT, g.NODE_TITLE_HEIGHT);
      a.fillStyle = "#FFF";
      a.fillText(e.order, e.pos[0] + -0.5 * g.NODE_TITLE_HEIGHT, e.pos[1] - 6);
    }
    a.globalAlpha = 1;
  };
  n.prototype.drawNodeWidgets = function(a, b, c, e) {
    if (!a.widgets || !a.widgets.length) {
      return 0;
    }
    var d = a.size[0], f = a.widgets;
    b += 2;
    var h = g.NODE_WIDGET_HEIGHT, k = 0.5 < this.ds.scale;
    c.save();
    c.globalAlpha = this.editor_alpha;
    for (var q = g.WIDGET_OUTLINE_COLOR, r = g.WIDGET_BGCOLOR, n = g.WIDGET_TEXT_COLOR, p = g.WIDGET_SECONDARY_TEXT_COLOR, x = 0; x < f.length; ++x) {
      var l = f[x], v = b;
      l.y && (v = l.y);
      l.last_y = v;
      c.strokeStyle = q;
      c.fillStyle = "#222";
      c.textAlign = "left";
      l.disabled && (c.globalAlpha *= 0.5);
      var m = l.width || d;
      switch(l.type) {
        case "button":
          l.clicked && (c.fillStyle = "#AAA", l.clicked = !1, this.dirty_canvas = !0);
          c.fillRect(15, v, m - 30, h);
          k && !l.disabled && c.strokeRect(15, v, m - 30, h);
          k && (c.textAlign = "center", c.fillStyle = n, c.fillText(l.name, 0.5 * m, v + 0.7 * h));
          break;
        case "toggle":
          c.textAlign = "left";
          c.strokeStyle = q;
          c.fillStyle = r;
          c.beginPath();
          k ? c.roundRect(15, v, m - 30, h, [0.5 * h]) : c.rect(15, v, m - 30, h);
          c.fill();
          k && !l.disabled && c.stroke();
          c.fillStyle = l.value ? "#89A" : "#333";
          c.beginPath();
          c.arc(m - 30, v + 0.5 * h, 0.36 * h, 0, 2 * Math.PI);
          c.fill();
          k && (c.fillStyle = p, null != l.name && c.fillText(l.name, 30, v + 0.7 * h), c.fillStyle = l.value ? n : p, c.textAlign = "right", c.fillText(l.value ? l.options.on || "true" : l.options.off || "false", m - 40, v + 0.7 * h));
          break;
        case "slider":
          c.fillStyle = r;
          c.fillRect(15, v, m - 30, h);
          var t = l.options.max - l.options.min, A = (l.value - l.options.min) / t;
          c.fillStyle = e == l ? "#89A" : "#678";
          c.fillRect(15, v, A * (m - 30), h);
          k && !l.disabled && c.strokeRect(15, v, m - 30, h);
          l.marker && (t = (l.marker - l.options.min) / t, c.fillStyle = "#AA9", c.fillRect(15 + t * (m - 30), v, 2, h));
          k && (c.textAlign = "center", c.fillStyle = n, c.fillText(l.name + "  " + Number(l.value).toFixed(3), 0.5 * m, v + 0.7 * h));
          break;
        case "number":
        case "combo":
          c.textAlign = "left";
          c.strokeStyle = q;
          c.fillStyle = r;
          c.beginPath();
          k ? c.roundRect(15, v, m - 30, h, [0.5 * h]) : c.rect(15, v, m - 30, h);
          c.fill();
          k && (l.disabled || c.stroke(), c.fillStyle = n, l.disabled || (c.beginPath(), c.moveTo(31, v + 5), c.lineTo(21, v + 0.5 * h), c.lineTo(31, v + h - 5), c.fill(), c.beginPath(), c.moveTo(m - 15 - 16, v + 5), c.lineTo(m - 15 - 6, v + 0.5 * h), c.lineTo(m - 15 - 16, v + h - 5), c.fill()), c.fillStyle = p, c.fillText(l.name, 35, v + 0.7 * h), c.fillStyle = n, c.textAlign = "right", "number" == l.type ? c.fillText(Number(l.value).toFixed(void 0 !== l.options.precision ? l.options.precision : 
          3), m - 30 - 20, v + 0.7 * h) : (t = l.value, l.options.values && (A = l.options.values, A.constructor === Function && (A = A()), A && A.constructor !== Array && (t = A[l.value])), c.fillText(t, m - 30 - 20, v + 0.7 * h)));
          break;
        case "string":
        case "text":
          c.textAlign = "left";
          c.strokeStyle = q;
          c.fillStyle = r;
          c.beginPath();
          k ? c.roundRect(15, v, m - 30, h, [0.5 * h]) : c.rect(15, v, m - 30, h);
          c.fill();
          k && (l.disabled || c.stroke(), c.save(), c.beginPath(), c.rect(15, v, m - 30, h), c.clip(), c.fillStyle = p, null != l.name && c.fillText(l.name, 30, v + 0.7 * h), c.fillStyle = n, c.textAlign = "right", c.fillText(String(l.value).substr(0, 30), m - 30, v + 0.7 * h), c.restore());
          break;
        default:
          l.draw && l.draw(c, a, m, v, h);
      }
      b += (l.computeSize ? l.computeSize(m)[1] : h) + 4;
      c.globalAlpha = this.editor_alpha;
    }
    c.restore();
    c.textAlign = "left";
  };
  n.prototype.processNodeWidgets = function(a, b, c, e) {
    function d(d, e) {
      d.value = e;
      d.options && d.options.property && void 0 !== a.properties[d.options.property] && a.setProperty(d.options.property, e);
      d.callback && d.callback(d.value, q, a, b, c);
    }
    if (!a.widgets || !a.widgets.length) {
      return null;
    }
    for (var f = b[0] - a.pos[0], h = b[1] - a.pos[1], k = a.size[0], q = this, r = this.getCanvasWindow(), n = 0; n < a.widgets.length; ++n) {
      var p = a.widgets[n];
      if (p && !p.disabled) {
        var l = p.computeSize ? p.computeSize(k)[1] : g.NODE_WIDGET_HEIGHT, x = p.width || k;
        if (p == e || !(6 > f || f > x - 12 || h < p.last_y || h > p.last_y + l || void 0 === p.last_y)) {
          e = p.value;
          switch(p.type) {
            case "button":
              c.type === g.pointerevents_method + "down" && (p.callback && setTimeout(function() {
                p.callback(p, q, a, b, c);
              }, 20), this.dirty_canvas = p.clicked = !0);
              break;
            case "slider":
              r = Math.clamp((f - 15) / (x - 30), 0, 1);
              p.value = p.options.min + (p.options.max - p.options.min) * r;
              p.callback && setTimeout(function() {
                d(p, p.value);
              }, 20);
              this.dirty_canvas = !0;
              break;
            case "number":
            case "combo":
              e = p.value;
              if (c.type == g.pointerevents_method + "move" && "number" == p.type) {
                p.value += 0.1 * c.deltaX * (p.options.step || 1), null != p.options.min && p.value < p.options.min && (p.value = p.options.min), null != p.options.max && p.value > p.options.max && (p.value = p.options.max);
              } else {
                if (c.type == g.pointerevents_method + "down") {
                  var v = p.options.values;
                  v && v.constructor === Function && (v = p.options.values(p, a));
                  var m = null;
                  "number" != p.type && (m = v.constructor === Array ? v : Object.keys(v));
                  f = 40 > f ? -1 : f > x - 40 ? 1 : 0;
                  if ("number" == p.type) {
                    p.value += 0.1 * f * (p.options.step || 1), null != p.options.min && p.value < p.options.min && (p.value = p.options.min), null != p.options.max && p.value > p.options.max && (p.value = p.options.max);
                  } else {
                    if (f) {
                      r = -1, this.last_mouseclick = 0, r = v.constructor === Object ? m.indexOf(String(p.value)) + f : m.indexOf(p.value) + f, r >= m.length && (r = m.length - 1), 0 > r && (r = 0), p.value = v.constructor === Array ? v[r] : r;
                    } else {
                      var t = v != m ? Object.values(v) : v;
                      new g.ContextMenu(t, {scale:Math.max(1, this.ds.scale), event:c, className:"dark", callback:function(a, b, c) {
                        v != m && (a = t.indexOf(a));
                        this.value = a;
                        d(this, a);
                        q.dirty_canvas = !0;
                        return !1;
                      }.bind(p)}, r);
                    }
                  }
                } else {
                  c.type == g.pointerevents_method + "up" && "number" == p.type && (f = 40 > f ? -1 : f > x - 40 ? 1 : 0, 200 > c.click_time && 0 == f && this.prompt("Value", p.value, function(a) {
                    this.value = Number(a);
                    d(this, this.value);
                  }.bind(p), c));
                }
              }
              e != p.value && setTimeout(function() {
                d(this, this.value);
              }.bind(p), 20);
              this.dirty_canvas = !0;
              break;
            case "toggle":
              c.type == g.pointerevents_method + "down" && (p.value = !p.value, setTimeout(function() {
                d(p, p.value);
              }, 20));
              break;
            case "string":
            case "text":
              c.type == g.pointerevents_method + "down" && this.prompt("Value", p.value, function(a) {
                this.value = a;
                d(this, a);
              }.bind(p), c, p.options ? p.options.multiline : !1);
              break;
            default:
              p.mouse && (this.dirty_canvas = p.mouse(c, [f, h], a));
          }
          if (e != p.value) {
            if (a.onWidgetChanged) {
              a.onWidgetChanged(p.name, p.value, e, p);
            }
            a.graph._version++;
          }
          return p;
        }
      }
    }
    return null;
  };
  n.prototype.drawGroups = function(a, b) {
    if (this.graph) {
      a = this.graph._groups;
      b.save();
      b.globalAlpha = 0.5 * this.editor_alpha;
      for (var c = 0; c < a.length; ++c) {
        var e = a[c];
        if (H(this.visible_area, e._bounding)) {
          b.fillStyle = e.color || "#335";
          b.strokeStyle = e.color || "#335";
          var d = e._pos, f = e._size;
          b.globalAlpha = 0.25 * this.editor_alpha;
          b.beginPath();
          b.rect(d[0] + 0.5, d[1] + 0.5, f[0], f[1]);
          b.fill();
          b.globalAlpha = this.editor_alpha;
          b.stroke();
          b.beginPath();
          b.moveTo(d[0] + f[0], d[1] + f[1]);
          b.lineTo(d[0] + f[0] - 10, d[1] + f[1]);
          b.lineTo(d[0] + f[0], d[1] + f[1] - 10);
          b.fill();
          f = e.font_size || g.DEFAULT_GROUP_FONT_SIZE;
          b.font = f + "px Arial";
          b.textAlign = "left";
          b.fillText(e.title, d[0] + 4, d[1] + f);
        }
      }
      b.restore();
    }
  };
  n.prototype.adjustNodesSize = function() {
    for (var a = this.graph._nodes, b = 0; b < a.length; ++b) {
      a[b].size = a[b].computeSize();
    }
    this.setDirty(!0, !0);
  };
  n.prototype.resize = function(a, b) {
    a || b || (b = this.canvas.parentNode, a = b.offsetWidth, b = b.offsetHeight);
    if (this.canvas.width != a || this.canvas.height != b) {
      this.canvas.width = a, this.canvas.height = b, this.bgcanvas.width = this.canvas.width, this.bgcanvas.height = this.canvas.height, this.setDirty(!0, !0);
    }
  };
  n.prototype.switchLiveMode = function(a) {
    if (a) {
      var b = this, c = this.live_mode ? 1.1 : 0.9;
      this.live_mode && (this.live_mode = !1, this.editor_alpha = 0.1);
      var e = setInterval(function() {
        b.editor_alpha *= c;
        b.dirty_canvas = !0;
        b.dirty_bgcanvas = !0;
        1 > c && 0.01 > b.editor_alpha && (clearInterval(e), 1 > c && (b.live_mode = !0));
        1 < c && 0.99 < b.editor_alpha && (clearInterval(e), b.editor_alpha = 1);
      }, 1);
    } else {
      this.live_mode = !this.live_mode, this.dirty_bgcanvas = this.dirty_canvas = !0;
    }
  };
  n.prototype.onNodeSelectionChange = function(a) {
  };
  n.onGroupAdd = function(a, b, c) {
    a = n.active_canvas;
    a.getCanvasWindow();
    b = new g.LGraphGroup;
    b.pos = a.convertEventToCanvasOffset(c);
    a.graph.add(b);
  };
  n.onMenuAdd = function(a, b, c, e, d) {
    function f(a, b) {
      var e = [];
      g.getNodeTypesCategories(h.filter || q.filter).filter(function(b) {
        return b.startsWith(a);
      }).map(function(b) {
        if (b) {
          b = b.replace(new RegExp("^(" + a + ")"), "").split("/")[0];
          var c = "" === a ? b + "/" : a + b + "/";
          -1 != b.indexOf("::") && (b = b.split("::")[1]);
          -1 === e.findIndex(function(a) {
            return a.value === c;
          }) && e.push({value:c, content:b, has_submenu:!0, callback:function(a, b, c, d) {
            f(a.value, d);
          }});
        }
      });
      g.getNodeTypesInCategory(a.slice(0, -1), h.filter || q.filter).map(function(a) {
        a.skip_list || e.push({value:a.type, content:a.title, has_submenu:!1, callback:function(a, b, c, e) {
          b = e.getFirstEvent();
          h.graph.beforeChange();
          if (a = g.createNode(a.value)) {
            a.pos = h.convertEventToCanvasOffset(b), h.graph.add(a);
          }
          d && d(a);
          h.graph.afterChange();
        }});
      });
      new g.ContextMenu(e, {event:c, parentMenu:b}, k);
    }
    var h = n.active_canvas, k = h.getCanvasWindow(), q = h.graph;
    if (q) {
      return f("", e), !1;
    }
  };
  n.onMenuCollapseAll = function() {
  };
  n.onMenuNodeEdit = function() {
  };
  n.showMenuNodeOptionalInputs = function(a, b, c, e, d) {
    if (d) {
      var f = this;
      a = n.active_canvas.getCanvasWindow();
      b = d.optional_inputs;
      d.onGetInputs && (b = d.onGetInputs());
      var h = [];
      if (b) {
        for (var k = 0; k < b.length; k++) {
          var q = b[k];
          if (q) {
            var r = q[0];
            q[2] || (q[2] = {});
            q[2].label && (r = q[2].label);
            q[2].removable = !0;
            r = {content:r, value:q};
            q[1] == g.ACTION && (r.className = "event");
            h.push(r);
          } else {
            h.push(null);
          }
        }
      }
      d.onMenuNodeInputs && (b = d.onMenuNodeInputs(h)) && (h = b);
      if (h.length) {
        return new g.ContextMenu(h, {event:c, callback:function(a, b, c) {
          if (d && (a.callback && a.callback.call(f, d, a, b, c), a.value)) {
            d.graph.beforeChange();
            d.addInput(a.value[0], a.value[1], a.value[2]);
            if (d.onNodeInputAdd) {
              d.onNodeInputAdd(a.value);
            }
            d.setDirtyCanvas(!0, !0);
            d.graph.afterChange();
          }
        }, parentMenu:e, node:d}, a), !1;
      }
      console.log("no input entries");
    }
  };
  n.showMenuNodeOptionalOutputs = function(a, b, c, e, d) {
    function f(a, b, c) {
      if (d && (a.callback && a.callback.call(h, d, a, b, c), a.value)) {
        if (c = a.value[1], !c || c.constructor !== Object && c.constructor !== Array) {
          d.graph.beforeChange();
          d.addOutput(a.value[0], a.value[1], a.value[2]);
          if (d.onNodeOutputAdd) {
            d.onNodeOutputAdd(a.value);
          }
          d.setDirtyCanvas(!0, !0);
          d.graph.afterChange();
        } else {
          a = [];
          for (var k in c) {
            a.push({content:k, value:c[k]});
          }
          new g.ContextMenu(a, {event:b, callback:f, parentMenu:e, node:d});
          return !1;
        }
      }
    }
    if (d) {
      var h = this;
      a = n.active_canvas.getCanvasWindow();
      b = d.optional_outputs;
      d.onGetOutputs && (b = d.onGetOutputs());
      var k = [];
      if (b) {
        for (var q = 0; q < b.length; q++) {
          var r = b[q];
          if (!r) {
            k.push(null);
          } else {
            if (!d.flags || !d.flags.skip_repeated_outputs || -1 == d.findOutputSlot(r[0])) {
              var u = r[0];
              r[2] || (r[2] = {});
              r[2].label && (u = r[2].label);
              r[2].removable = !0;
              u = {content:u, value:r};
              r[1] == g.EVENT && (u.className = "event");
              k.push(u);
            }
          }
        }
      }
      this.onMenuNodeOutputs && (k = this.onMenuNodeOutputs(k));
      g.do_add_triggers_slots && -1 == d.findOutputSlot("onExecuted") && k.push({content:"On Executed", value:["onExecuted", g.EVENT, {nameLocked:!0}], className:"event"});
      d.onMenuNodeOutputs && (b = d.onMenuNodeOutputs(k)) && (k = b);
      if (k.length) {
        return new g.ContextMenu(k, {event:c, callback:f, parentMenu:e, node:d}, a), !1;
      }
    }
  };
  n.onShowMenuNodeProperties = function(a, b, c, e, d) {
    if (d && d.properties) {
      var f = n.active_canvas;
      b = f.getCanvasWindow();
      var h = [], k;
      for (k in d.properties) {
        a = void 0 !== d.properties[k] ? d.properties[k] : " ";
        "object" == typeof a && (a = JSON.stringify(a));
        var q = d.getPropertyInfo(k);
        if ("enum" == q.type || "combo" == q.type) {
          a = n.getPropertyPrintableValue(a, q.values);
        }
        a = n.decodeHTML(a);
        h.push({content:"<span class='property_name'>" + (q.label ? q.label : k) + "</span><span class='property_value'>" + a + "</span>", value:k});
      }
      if (h.length) {
        return new g.ContextMenu(h, {event:c, callback:function(a, b, c, e) {
          d && (b = this.getBoundingClientRect(), f.showEditPropertyValue(d, a.value, {position:[b.left, b.top]}));
        }, parentMenu:e, allow_html:!0, node:d}, b), !1;
      }
    }
  };
  n.decodeHTML = function(a) {
    var b = document.createElement("div");
    b.innerText = a;
    return b.innerHTML;
  };
  n.onMenuResizeNode = function(a, b, c, e, d) {
    if (d) {
      a = function(a) {
        a.size = a.computeSize();
        if (a.onResize) {
          a.onResize(a.size);
        }
      };
      b = n.active_canvas;
      if (!b.selected_nodes || 1 >= Object.keys(b.selected_nodes).length) {
        a(d);
      } else {
        for (var f in b.selected_nodes) {
          a(b.selected_nodes[f]);
        }
      }
      d.setDirtyCanvas(!0, !0);
    }
  };
  n.prototype.showLinkMenu = function(a, b) {
    var c = this, e = c.graph.getNodeById(a.origin_id), d = c.graph.getNodeById(a.target_id), f = !1;
    e && e.outputs && e.outputs[a.origin_slot] && (f = e.outputs[a.origin_slot].type);
    var h = !1;
    d && d.outputs && d.outputs[a.target_slot] && (h = d.inputs[a.target_slot].type);
    var k = new g.ContextMenu(["Add Node", null, "Delete", null], {event:b, title:null != a.data ? a.data.constructor.name : null, callback:function(b, g, u) {
      switch(b) {
        case "Add Node":
          n.onMenuAdd(null, null, u, k, function(b) {
            b.inputs && b.inputs.length && b.outputs && b.outputs.length && e.connectByType(a.origin_slot, b, f) && (b.connectByType(a.target_slot, d, h), b.pos[0] -= 0.5 * b.size[0]);
          });
          break;
        case "Delete":
          c.graph.removeLink(a.id);
      }
    }});
    return !1;
  };
  n.prototype.createDefaultNodeForSlot = function(a) {
    a = a || {};
    a = Object.assign({nodeFrom:null, slotFrom:null, nodeTo:null, slotTo:null, position:[], nodeType:null, posAdd:[0, 0], posSizeFix:[0, 0]}, a);
    var b = a.nodeFrom && null !== a.slotFrom, c = !b && a.nodeTo && null !== a.slotTo;
    if (!b && !c) {
      return console.warn("No data passed to createDefaultNodeForSlot " + a.nodeFrom + " " + a.slotFrom + " " + a.nodeTo + " " + a.slotTo), !1;
    }
    if (!a.nodeType) {
      return console.warn("No type to createDefaultNodeForSlot"), !1;
    }
    var e = b ? a.nodeFrom : a.nodeTo, d = b ? a.slotFrom : a.slotTo;
    switch(typeof d) {
      case "string":
        c = b ? e.findOutputSlot(d, !1) : e.findInputSlot(d, !1);
        d = b ? e.outputs[d] : e.inputs[d];
        break;
      case "object":
        c = b ? e.findOutputSlot(d.name) : e.findInputSlot(d.name);
        break;
      case "number":
        c = d;
        d = b ? e.outputs[d] : e.inputs[d];
        break;
      default:
        return console.warn("Cant get slot information " + d), !1;
    }
    !1 !== d && !1 !== c || console.warn("createDefaultNodeForSlot bad slotX " + d + " " + c);
    e = d.type == g.EVENT ? "_event_" : d.type;
    if ((d = b ? g.slot_types_default_out : g.slot_types_default_in) && d[e]) {
      nodeNewType = !1;
      if ("object" == typeof d[e] || "array" == typeof d[e]) {
        for (var f in d[e]) {
          if (a.nodeType == d[e][f] || "AUTO" == a.nodeType) {
            nodeNewType = d[e][f];
            break;
          }
        }
      } else {
        if (a.nodeType == d[e] || "AUTO" == a.nodeType) {
          nodeNewType = d[e];
        }
      }
      if (nodeNewType) {
        f = !1;
        "object" == typeof nodeNewType && nodeNewType.node && (f = nodeNewType, nodeNewType = nodeNewType.node);
        if (d = g.createNode(nodeNewType)) {
          if (f) {
            if (f.properties) {
              for (var h in f.properties) {
                d.addProperty(h, f.properties[h]);
              }
            }
            if (f.inputs) {
              for (h in d.inputs = [], f.inputs) {
                d.addOutput(f.inputs[h][0], f.inputs[h][1]);
              }
            }
            if (f.outputs) {
              for (h in d.outputs = [], f.outputs) {
                d.addOutput(f.outputs[h][0], f.outputs[h][1]);
              }
            }
            f.title && (d.title = f.title);
            f.json && d.configure(f.json);
          }
          this.graph.add(d);
          d.pos = [a.position[0] + a.posAdd[0] + (a.posSizeFix[0] ? a.posSizeFix[0] * d.size[0] : 0), a.position[1] + a.posAdd[1] + (a.posSizeFix[1] ? a.posSizeFix[1] * d.size[1] : 0)];
          b ? a.nodeFrom.connectByType(c, d, e) : a.nodeTo.connectByTypeOutput(c, d, e);
          return !0;
        }
        console.log("failed creating " + nodeNewType);
      }
    }
    return !1;
  };
  n.prototype.showConnectionMenu = function(a) {
    a = a || {};
    var b = Object.assign({nodeFrom:null, slotFrom:null, nodeTo:null, slotTo:null, e:null}, a), c = this, e = b.nodeFrom && b.slotFrom;
    a = !e && b.nodeTo && b.slotTo;
    if (!e && !a) {
      return console.warn("No data passed to showConnectionMenu"), !1;
    }
    a = e ? b.nodeFrom : b.nodeTo;
    var d = e ? b.slotFrom : b.slotTo, f = !1;
    switch(typeof d) {
      case "string":
        f = e ? a.findOutputSlot(d, !1) : a.findInputSlot(d, !1);
        d = e ? a.outputs[d] : a.inputs[d];
        break;
      case "object":
        f = e ? a.findOutputSlot(d.name) : a.findInputSlot(d.name);
        break;
      case "number":
        f = d;
        d = e ? a.outputs[d] : a.inputs[d];
        break;
      default:
        return console.warn("Cant get slot information " + d), !1;
    }
    a = ["Add Node", null];
    c.allow_searchbox && (a.push("Search"), a.push(null));
    var h = d.type == g.EVENT ? "_event_" : d.type, k = e ? g.slot_types_default_out : g.slot_types_default_in;
    if (k && k[h]) {
      if ("object" == typeof k[h] || "array" == typeof k[h]) {
        for (var q in k[h]) {
          a.push(k[h][q]);
        }
      } else {
        a.push(k[h]);
      }
    }
    var r = new g.ContextMenu(a, {event:b.e, title:(d && "" != d.name ? d.name + (h ? " | " : "") : "") + (d && h ? h : ""), callback:function(a, g, k) {
      switch(a) {
        case "Add Node":
          n.onMenuAdd(null, null, k, r, function(a) {
            e ? b.nodeFrom.connectByType(f, a, h) : b.nodeTo.connectByTypeOutput(f, a, h);
          });
          break;
        case "Search":
          e ? c.showSearchBox(k, {node_from:b.nodeFrom, slot_from:d, type_filter_in:h}) : c.showSearchBox(k, {node_to:b.nodeTo, slot_from:d, type_filter_out:h});
          break;
        default:
          c.createDefaultNodeForSlot(Object.assign(b, {position:[b.e.canvasX, b.e.canvasY], nodeType:a}));
      }
    }});
    return !1;
  };
  n.onShowPropertyEditor = function(a, b, c, e, d) {
    function f() {
      if (q) {
        var b = q.value;
        "Number" == a.type ? b = Number(b) : "Boolean" == a.type && (b = !!b);
        d[h] = b;
        k.parentNode && k.parentNode.removeChild(k);
        d.setDirtyCanvas(!0, !0);
      }
    }
    var h = a.property || "title";
    b = d[h];
    var k = document.createElement("div");
    k.is_modified = !1;
    k.className = "graphdialog";
    k.innerHTML = "<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>";
    k.close = function() {
      k.parentNode && k.parentNode.removeChild(k);
    };
    k.querySelector(".name").innerText = h;
    var q = k.querySelector(".value");
    q && (q.value = b, q.addEventListener("blur", function(a) {
      this.focus();
    }), q.addEventListener("keydown", function(a) {
      k.is_modified = !0;
      if (27 == a.keyCode) {
        k.close();
      } else {
        if (13 == a.keyCode) {
          f();
        } else {
          if (13 != a.keyCode && "textarea" != a.target.localName) {
            return;
          }
        }
      }
      a.preventDefault();
      a.stopPropagation();
    }));
    b = n.active_canvas.canvas;
    c = b.getBoundingClientRect();
    var r = e = -20;
    c && (e -= c.left, r -= c.top);
    event ? (k.style.left = event.clientX + e + "px", k.style.top = event.clientY + r + "px") : (k.style.left = 0.5 * b.width + e + "px", k.style.top = 0.5 * b.height + r + "px");
    k.querySelector("button").addEventListener("click", f);
    b.parentNode.appendChild(k);
    q && q.focus();
    var u = null;
    k.addEventListener("mouseleave", function(a) {
      g.dialog_close_on_mouse_leave && !k.is_modified && g.dialog_close_on_mouse_leave && (u = setTimeout(k.close, g.dialog_close_on_mouse_leave_delay));
    });
    k.addEventListener("mouseenter", function(a) {
      g.dialog_close_on_mouse_leave && u && clearTimeout(u);
    });
  };
  n.prototype.prompt = function(a, b, c, e, d) {
    var f = this;
    a = a || "";
    var h = document.createElement("div");
    h.is_modified = !1;
    h.className = "graphdialog rounded";
    h.innerHTML = d ? "<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>" : "<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>";
    h.close = function() {
      f.prompt_box = null;
      h.parentNode && h.parentNode.removeChild(h);
    };
    d = n.active_canvas.canvas;
    d.parentNode.appendChild(h);
    1 < this.ds.scale && (h.style.transform = "scale(" + this.ds.scale + ")");
    var k = null, q = !1;
    g.pointerListenerAdd(h, "leave", function(a) {
      q || g.dialog_close_on_mouse_leave && !h.is_modified && g.dialog_close_on_mouse_leave && (k = setTimeout(h.close, g.dialog_close_on_mouse_leave_delay));
    });
    g.pointerListenerAdd(h, "enter", function(a) {
      g.dialog_close_on_mouse_leave && k && clearTimeout(k);
    });
    var r = h.querySelectorAll("select");
    r && r.forEach(function(a) {
      a.addEventListener("click", function(a) {
        q++;
      });
      a.addEventListener("blur", function(a) {
        q = 0;
      });
      a.addEventListener("change", function(a) {
        q = -1;
      });
    });
    f.prompt_box && f.prompt_box.close();
    f.prompt_box = h;
    h.querySelector(".name").innerText = a;
    var u = h.querySelector(".value");
    u.value = b;
    u.addEventListener("keydown", function(a) {
      h.is_modified = !0;
      if (27 == a.keyCode) {
        h.close();
      } else {
        if (13 == a.keyCode && "textarea" != a.target.localName) {
          c && c(this.value), h.close();
        } else {
          return;
        }
      }
      a.preventDefault();
      a.stopPropagation();
    });
    h.querySelector("button").addEventListener("click", function(a) {
      c && c(u.value);
      f.setDirty(!0);
      h.close();
    });
    a = d.getBoundingClientRect();
    r = b = -20;
    a && (b -= a.left, r -= a.top);
    e ? (h.style.left = e.clientX + b + "px", h.style.top = e.clientY + r + "px") : (h.style.left = 0.5 * d.width + b + "px", h.style.top = 0.5 * d.height + r + "px");
    setTimeout(function() {
      u.focus();
    }, 10);
    return h;
  };
  n.search_limit = -1;
  n.prototype.showSearchBox = function(a, b) {
    function c(c) {
      if (c) {
        if (f.onSearchBoxSelection) {
          f.onSearchBoxSelection(c, a, h);
        } else {
          var d = g.searchbox_extras[c.toLowerCase()];
          d && (c = d.type);
          h.graph.beforeChange();
          if (c = g.createNode(c)) {
            c.pos = h.convertEventToCanvasOffset(a), h.graph.add(c, !1);
          }
          if (d && d.data) {
            if (d.data.properties) {
              for (var e in d.data.properties) {
                c.addProperty(e, d.data.properties[e]);
              }
            }
            if (d.data.inputs) {
              for (e in c.inputs = [], d.data.inputs) {
                c.addOutput(d.data.inputs[e][0], d.data.inputs[e][1]);
              }
            }
            if (d.data.outputs) {
              for (e in c.outputs = [], d.data.outputs) {
                c.addOutput(d.data.outputs[e][0], d.data.outputs[e][1]);
              }
            }
            d.data.title && (c.title = d.data.title);
            d.data.json && c.configure(d.data.json);
          }
          if (b.node_from) {
            switch(typeof b.slot_from) {
              case "string":
                d = b.node_from.findOutputSlot(b.slot_from);
                break;
              case "object":
                d = b.slot_from.name ? b.node_from.findOutputSlot(b.slot_from.name) : -1;
                -1 == d && "undefined" !== typeof b.slot_from.slot_index && (d = b.slot_from.slot_index);
                break;
              case "number":
                d = b.slot_from;
                break;
              default:
                d = 0;
            }
            !1 !== d && -1 < d && b.node_from.connectByType(d, c, b.node_from.outputs[d].type);
          }
          if (b.node_to) {
            switch(typeof b.slot_from) {
              case "string":
                d = b.node_to.findInputSlot(b.slot_from);
                break;
              case "object":
                d = b.slot_from.name ? b.node_to.findInputSlot(b.slot_from.name) : -1;
                -1 == d && "undefined" !== typeof b.slot_from.slot_index && (d = b.slot_from.slot_index);
                break;
              case "number":
                d = b.slot_from;
                break;
              default:
                d = 0;
            }
            !1 !== d && -1 < d && b.node_to.connectByTypeOutput(d, c, b.node_to.inputs[d].type);
          }
          h.graph.afterChange();
        }
      }
      r.close();
    }
    function e(a) {
      var b = w;
      w && w.classList.remove("selected");
      w ? (w = a ? w.nextSibling : w.previousSibling) || (w = b) : w = a ? m.childNodes[0] : m.childNodes[m.childNodes.length];
      w && (w.classList.add("selected"), w.scrollIntoView({block:"end", behavior:"smooth"}));
    }
    function d() {
      function a(a, b) {
        var d = document.createElement("div");
        t || (t = a);
        d.innerText = a;
        d.dataset.type = escape(a);
        d.className = "litegraph lite-search-item";
        b && (d.className += " " + b);
        d.addEventListener("click", function(a) {
          c(unescape(this.dataset.type));
        });
        m.appendChild(d);
      }
      A = null;
      var d = y.value;
      t = null;
      m.innerHTML = "";
      if (d || b.show_all_if_empty) {
        if (f.onSearchBox) {
          var e = f.onSearchBox(m, d, h);
          if (e) {
            for (var k = 0; k < e.length; ++k) {
              a(e[k]);
            }
          }
        } else {
          e = function(a, c) {
            c = c || {};
            c = Object.assign({skipFilter:!1, inTypeOverride:!1, outTypeOverride:!1}, c);
            var e = g.registered_node_types[a];
            if (r && e.filter != r || (!b.show_all_if_empty || d) && -1 === a.toLowerCase().indexOf(d)) {
              return !1;
            }
            if (b.do_type_filter && !c.skipFilter) {
              e = p.value;
              !1 !== c.inTypeOverride && (e = c.inTypeOverride);
              if (p && e && g.registered_slot_in_types[e] && g.registered_slot_in_types[e].nodes && (e = g.registered_slot_in_types[e].nodes.includes(a), !1 === e)) {
                return !1;
              }
              e = l.value;
              !1 !== c.outTypeOverride && (e = c.outTypeOverride);
              if (l && e && g.registered_slot_out_types[e] && g.registered_slot_out_types[e].nodes && (e = g.registered_slot_out_types[e].nodes.includes(a), !1 === e)) {
                return !1;
              }
            }
            return !0;
          };
          var q = 0;
          d = d.toLowerCase();
          var r = h.filter || h.graph.filter;
          if (b.do_type_filter && f.search_box) {
            var p = f.search_box.querySelector(".slot_in_type_filter"), l = f.search_box.querySelector(".slot_out_type_filter");
          } else {
            l = p = !1;
          }
          for (k in g.searchbox_extras) {
            var u = g.searchbox_extras[k];
            if (b.show_all_if_empty && !d || -1 !== u.desc.toLowerCase().indexOf(d)) {
              var x = g.registered_node_types[u.type];
              if ((!x || x.filter == r) && e(u.type) && (a(u.desc, "searchbox_extra"), -1 !== n.search_limit && q++ > n.search_limit)) {
                break;
              }
            }
          }
          u = null;
          if (Array.prototype.filter) {
            u = Object.keys(g.registered_node_types).filter(e);
          } else {
            for (k in u = [], g.registered_node_types) {
              e(k) && u.push(k);
            }
          }
          for (k = 0; k < u.length && !(a(u[k]), -1 !== n.search_limit && q++ > n.search_limit); k++) {
          }
          if (b.show_general_after_typefiltered && (p.value || l.value)) {
            filtered_extra = [];
            for (k in g.registered_node_types) {
              e(k, {inTypeOverride:p && p.value ? "*" : !1, outTypeOverride:l && l.value ? "*" : !1}) && filtered_extra.push(k);
            }
            for (k = 0; k < filtered_extra.length && !(a(filtered_extra[k], "generic_type"), -1 !== n.search_limit && q++ > n.search_limit); k++) {
            }
          }
          if ((p.value || l.value) && 0 == m.childNodes.length && b.show_general_if_none_on_typefilter) {
            filtered_extra = [];
            for (k in g.registered_node_types) {
              e(k, {skipFilter:!0}) && filtered_extra.push(k);
            }
            for (k = 0; k < filtered_extra.length && !(a(filtered_extra[k], "not_in_filter"), -1 !== n.search_limit && q++ > n.search_limit); k++) {
            }
          }
        }
      }
    }
    def_options = {slot_from:null, node_from:null, node_to:null, do_type_filter:g.search_filter_enabled, type_filter_in:!1, type_filter_out:!1, show_general_if_none_on_typefilter:!0, show_general_after_typefiltered:!0, hide_on_mouse_leave:g.search_hide_on_mouse_leave, show_all_if_empty:!0, show_all_on_open:g.search_show_all_on_open};
    b = Object.assign(def_options, b || {});
    var f = this, h = n.active_canvas, k = h.canvas, q = k.ownerDocument || document, r = document.createElement("div");
    r.className = "litegraph litesearchbox graphdialog rounded";
    r.innerHTML = "<span class='name'>Search</span> <input autofocus type='text' placeholder='search' class='value rounded'/>";
    b.do_type_filter && (r.innerHTML += "<select class='slot_in_type_filter'><option value=''></option></select>", r.innerHTML += "<select class='slot_out_type_filter'><option value=''></option></select>");
    r.innerHTML += "<div class='helper'></div>";
    q.fullscreenElement ? q.fullscreenElement.appendChild(r) : (q.body.appendChild(r), q.body.style.overflow = "hidden");
    if (b.do_type_filter) {
      var u = r.querySelector(".slot_in_type_filter"), p = r.querySelector(".slot_out_type_filter");
    }
    r.close = function() {
      f.search_box = null;
      this.blur();
      k.focus();
      q.body.style.overflow = "";
      setTimeout(function() {
        f.canvas.focus();
      }, 20);
      r.parentNode && r.parentNode.removeChild(r);
    };
    1 < this.ds.scale && (r.style.transform = "scale(" + this.ds.scale + ")");
    if (b.hide_on_mouse_leave) {
      var l = !1, x = null;
      g.pointerListenerAdd(r, "enter", function(a) {
        x && (clearTimeout(x), x = null);
      });
      g.pointerListenerAdd(r, "leave", function(a) {
        l || (x = setTimeout(function() {
          r.close();
        }, 500));
      });
      b.do_type_filter && (u.addEventListener("click", function(a) {
        l++;
      }), u.addEventListener("blur", function(a) {
        l = 0;
      }), u.addEventListener("change", function(a) {
        l = -1;
      }), p.addEventListener("click", function(a) {
        l++;
      }), p.addEventListener("blur", function(a) {
        l = 0;
      }), p.addEventListener("change", function(a) {
        l = -1;
      }));
    }
    f.search_box && f.search_box.close();
    f.search_box = r;
    var m = r.querySelector(".helper"), t = null, A = null, w = null, y = r.querySelector("input");
    y && (y.addEventListener("blur", function(a) {
      this.focus();
    }), y.addEventListener("keydown", function(a) {
      if (38 == a.keyCode) {
        e(!1);
      } else {
        if (40 == a.keyCode) {
          e(!0);
        } else {
          if (27 == a.keyCode) {
            r.close();
          } else {
            if (13 == a.keyCode) {
              w ? c(w.innerHTML) : t ? c(t) : r.close();
            } else {
              A && clearInterval(A);
              A = setTimeout(d, 250);
              return;
            }
          }
        }
      }
      a.preventDefault();
      a.stopPropagation();
      a.stopImmediatePropagation();
      return !0;
    }));
    if (b.do_type_filter) {
      if (u) {
        var z = g.slot_types_in, G = z.length;
        if (b.type_filter_in == g.EVENT || b.type_filter_in == g.ACTION) {
          b.type_filter_in = "_event_";
        }
        for (var B = 0; B < G; B++) {
          var C = document.createElement("option");
          C.value = z[B];
          C.innerHTML = z[B];
          u.appendChild(C);
          !1 !== b.type_filter_in && (b.type_filter_in + "").toLowerCase() == (z[B] + "").toLowerCase() && (C.selected = !0);
        }
        u.addEventListener("change", function() {
          d();
        });
      }
      if (p) {
        z = g.slot_types_out;
        G = z.length;
        if (b.type_filter_out == g.EVENT || b.type_filter_out == g.ACTION) {
          b.type_filter_out = "_event_";
        }
        for (B = 0; B < G; B++) {
          C = document.createElement("option"), C.value = z[B], C.innerHTML = z[B], p.appendChild(C), !1 !== b.type_filter_out && (b.type_filter_out + "").toLowerCase() == (z[B] + "").toLowerCase() && (C.selected = !0);
        }
        p.addEventListener("change", function() {
          d();
        });
      }
    }
    u = k.getBoundingClientRect();
    p = (a ? a.clientY : u.top + 0.5 * u.height) - 20;
    r.style.left = (a ? a.clientX : u.left + 0.5 * u.width) - 80 + "px";
    r.style.top = p + "px";
    a.layerY > u.height - 200 && (m.style.maxHeight = u.height - a.layerY - 20 + "px");
    y.focus();
    b.show_all_on_open && d();
    return r;
  };
  n.prototype.showEditPropertyValue = function(a, b, c) {
    function e() {
      d(p.value);
    }
    function d(d) {
      f && f.values && f.values.constructor === Object && void 0 != f.values[d] && (d = f.values[d]);
      "number" == typeof a.properties[b] && (d = Number(d));
      if ("array" == h || "object" == h) {
        d = JSON.parse(d);
      }
      a.properties[b] = d;
      a.graph && a.graph._version++;
      if (a.onPropertyChanged) {
        a.onPropertyChanged(b, d);
      }
      if (c.onclose) {
        c.onclose();
      }
      l.close();
      a.setDirtyCanvas(!0, !0);
    }
    if (a && void 0 !== a.properties[b]) {
      c = c || {};
      var f = a.getPropertyInfo(b), h = f.type, g = "";
      if ("string" == h || "number" == h || "array" == h || "object" == h) {
        g = "<input autofocus type='text' class='value'/>";
      } else {
        if ("enum" != h && "combo" != h || !f.values) {
          if ("boolean" == h || "toggle" == h) {
            g = "<input autofocus type='checkbox' class='value' " + (a.properties[b] ? "checked" : "") + "/>";
          } else {
            console.warn("unknown type: " + h);
            return;
          }
        } else {
          g = "<select autofocus type='text' class='value'>";
          for (var q in f.values) {
            var n = q;
            f.values.constructor === Array && (n = f.values[q]);
            g += "<option value='" + n + "' " + (n == a.properties[b] ? "selected" : "") + ">" + f.values[q] + "</option>";
          }
          g += "</select>";
        }
      }
      var l = this.createDialog("<span class='name'>" + (f.label ? f.label : b) + "</span>" + g + "<button>OK</button>", c), p = !1;
      if ("enum" != h && "combo" != h || !f.values) {
        if ("boolean" == h || "toggle" == h) {
          (p = l.querySelector("input")) && p.addEventListener("click", function(a) {
            l.modified();
            d(!!p.checked);
          });
        } else {
          if (p = l.querySelector("input")) {
            p.addEventListener("blur", function(a) {
              this.focus();
            }), n = void 0 !== a.properties[b] ? a.properties[b] : "", "string" !== h && (n = JSON.stringify(n)), p.value = n, p.addEventListener("keydown", function(a) {
              if (27 == a.keyCode) {
                l.close();
              } else {
                if (13 == a.keyCode) {
                  e();
                } else {
                  if (13 != a.keyCode) {
                    l.modified();
                    return;
                  }
                }
              }
              a.preventDefault();
              a.stopPropagation();
            });
          }
        }
      } else {
        p = l.querySelector("select"), p.addEventListener("change", function(a) {
          l.modified();
          d(a.target.value);
        });
      }
      p && p.focus();
      l.querySelector("button").addEventListener("click", e);
      return l;
    }
  };
  n.prototype.createDialog = function(a, b) {
    def_options = {checkForInput:!1, closeOnLeave:!0, closeOnLeave_checkModified:!0};
    b = Object.assign(def_options, b || {});
    var c = document.createElement("div");
    c.className = "graphdialog";
    c.innerHTML = a;
    c.is_modified = !1;
    a = this.canvas.getBoundingClientRect();
    var e = -20, d = -20;
    a && (e -= a.left, d -= a.top);
    b.position ? (e += b.position[0], d += b.position[1]) : b.event ? (e += b.event.clientX, d += b.event.clientY) : (e += 0.5 * this.canvas.width, d += 0.5 * this.canvas.height);
    c.style.left = e + "px";
    c.style.top = d + "px";
    this.canvas.parentNode.appendChild(c);
    b.checkForInput && (a = [], (a = c.querySelectorAll("input")) && a.forEach(function(a) {
      a.addEventListener("keydown", function(a) {
        c.modified();
        if (27 == a.keyCode) {
          c.close();
        } else {
          if (13 != a.keyCode) {
            return;
          }
        }
        a.preventDefault();
        a.stopPropagation();
      });
      a.focus();
    }));
    c.modified = function() {
      c.is_modified = !0;
    };
    c.close = function() {
      c.parentNode && c.parentNode.removeChild(c);
    };
    var f = null, h = !1;
    c.addEventListener("mouseleave", function(a) {
      h || (b.closeOnLeave || g.dialog_close_on_mouse_leave) && !c.is_modified && g.dialog_close_on_mouse_leave && (f = setTimeout(c.close, g.dialog_close_on_mouse_leave_delay));
    });
    c.addEventListener("mouseenter", function(a) {
      (b.closeOnLeave || g.dialog_close_on_mouse_leave) && f && clearTimeout(f);
    });
    (a = c.querySelectorAll("select")) && a.forEach(function(a) {
      a.addEventListener("click", function(a) {
        h++;
      });
      a.addEventListener("blur", function(a) {
        h = 0;
      });
      a.addEventListener("change", function(a) {
        h = -1;
      });
    });
    return c;
  };
  n.prototype.createPanel = function(a, b) {
    b = b || {};
    var c = b.window || window, e = document.createElement("div");
    e.className = "litegraph dialog";
    e.innerHTML = "<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div style='display:none;' class='dialog-alt-content'></div><div class='dialog-footer'></div>";
    e.header = e.querySelector(".dialog-header");
    b.width && (e.style.width = b.width + (b.width.constructor === Number ? "px" : ""));
    b.height && (e.style.height = b.height + (b.height.constructor === Number ? "px" : ""));
    b.closable && (b = document.createElement("span"), b.innerHTML = "&#10005;", b.classList.add("close"), b.addEventListener("click", function() {
      e.close();
    }), e.header.appendChild(b));
    e.title_element = e.querySelector(".dialog-title");
    e.title_element.innerText = a;
    e.content = e.querySelector(".dialog-content");
    e.alt_content = e.querySelector(".dialog-alt-content");
    e.footer = e.querySelector(".dialog-footer");
    e.close = function() {
      if (e.onClose && "function" == typeof e.onClose) {
        e.onClose();
      }
      e.parentNode.removeChild(e);
      this.parentNode && this.parentNode.removeChild(this);
    };
    e.toggleAltContent = function(a) {
      if ("undefined" != typeof a) {
        var b = a ? "block" : "none";
        a = a ? "none" : "block";
      } else {
        b = "block" != e.alt_content.style.display ? "block" : "none", a = "block" != e.alt_content.style.display ? "none" : "block";
      }
      e.alt_content.style.display = b;
      e.content.style.display = a;
    };
    e.toggleFooterVisibility = function(a) {
      e.footer.style.display = "undefined" != typeof a ? a ? "block" : "none" : "block" != e.footer.style.display ? "block" : "none";
    };
    e.clear = function() {
      this.content.innerHTML = "";
    };
    e.addHTML = function(a, b, c) {
      var d = document.createElement("div");
      b && (d.className = b);
      d.innerHTML = a;
      c ? e.footer.appendChild(d) : e.content.appendChild(d);
      return d;
    };
    e.addButton = function(a, b, c) {
      var d = document.createElement("button");
      d.innerText = a;
      d.options = c;
      d.classList.add("btn");
      d.addEventListener("click", b);
      e.footer.appendChild(d);
      return d;
    };
    e.addSeparator = function() {
      var a = document.createElement("div");
      a.className = "separator";
      e.content.appendChild(a);
    };
    e.addWidget = function(a, b, h, k, q) {
      function d(a, b) {
        k.callback && k.callback(a, b, k);
        q && q(a, b, k);
      }
      k = k || {};
      var f = String(h);
      a = a.toLowerCase();
      "number" == a && (f = h.toFixed(3));
      var p = document.createElement("div");
      p.className = "property";
      p.innerHTML = "<span class='property_name'></span><span class='property_value'></span>";
      p.querySelector(".property_name").innerText = k.label || b;
      var l = p.querySelector(".property_value");
      l.innerText = f;
      p.dataset.property = b;
      p.dataset.type = k.type || a;
      p.options = k;
      p.value = h;
      if ("code" == a) {
        p.addEventListener("click", function(a) {
          e.inner_showCodePad(this.dataset.property);
        });
      } else {
        if ("boolean" == a) {
          p.classList.add("boolean"), h && p.classList.add("bool-on"), p.addEventListener("click", function() {
            var a = this.dataset.property;
            this.value = !this.value;
            this.classList.toggle("bool-on");
            this.querySelector(".property_value").innerText = this.value ? "true" : "false";
            d(a, this.value);
          });
        } else {
          if ("string" == a || "number" == a) {
            l.setAttribute("contenteditable", !0), l.addEventListener("keydown", function(b) {
              "Enter" != b.code || "string" == a && b.shiftKey || (b.preventDefault(), this.blur());
            }), l.addEventListener("blur", function() {
              var a = this.innerText, b = this.parentNode.dataset.property;
              "number" == this.parentNode.dataset.type && (a = Number(a));
              d(b, a);
            });
          } else {
            if ("enum" == a || "combo" == a) {
              f = n.getPropertyPrintableValue(h, k.values), l.innerText = f, l.addEventListener("click", function(a) {
                var b = this.parentNode.dataset.property, e = this;
                new g.ContextMenu(k.values || [], {event:a, className:"dark", callback:function(a, c, f) {
                  e.innerText = a;
                  d(b, a);
                  return !1;
                }}, c);
              });
            }
          }
        }
      }
      e.content.appendChild(p);
      return p;
    };
    if (e.onOpen && "function" == typeof e.onOpen) {
      e.onOpen();
    }
    return e;
  };
  n.getPropertyPrintableValue = function(a, b) {
    if (!b || b.constructor === Array) {
      return String(a);
    }
    if (b.constructor === Object) {
      var c = "", e;
      for (e in b) {
        if (b[e] == a) {
          c = e;
          break;
        }
      }
      return String(a) + " (" + c + ")";
    }
  };
  n.prototype.closePanels = function() {
    var a = document.querySelector("#node-panel");
    a && a.close();
    (a = document.querySelector("#option-panel")) && a.close();
  };
  n.prototype.showShowGraphOptionsPanel = function(a, b, c, e) {
    if (this.constructor && "HTMLDivElement" == this.constructor.name) {
      if (!(b && b.event && b.event.target && b.event.target.lgraphcanvas)) {
        console.warn("Canvas not found");
        return;
      }
      var d = b.event.target.lgraphcanvas;
    } else {
      d = this;
    }
    d.closePanels();
    a = d.getCanvasWindow();
    panel = d.createPanel("Options", {closable:!0, window:a, onOpen:function() {
      d.OPTIONPANEL_IS_OPEN = !0;
    }, onClose:function() {
      d.OPTIONPANEL_IS_OPEN = !1;
      d.options_panel = null;
    }});
    d.options_panel = panel;
    panel.id = "option-panel";
    panel.classList.add("settings");
    (function() {
      panel.content.innerHTML = "";
      var a = function(a, b, c) {
        c && c.key && (a = c.key);
        c.values && (b = Object.values(c.values).indexOf(b));
        d[a] = b;
      }, b = g.availableCanvasOptions;
      b.sort();
      for (pI in b) {
        var c = b[pI];
        panel.addWidget("boolean", c, d[c], {key:c, on:"True", off:"False"}, a);
      }
      panel.addWidget("combo", "Render mode", g.LINK_RENDER_MODES[d.links_render_mode], {key:"links_render_mode", values:g.LINK_RENDER_MODES}, a);
      panel.addSeparator();
      panel.footer.innerHTML = "";
    })();
    d.canvas.parentNode.appendChild(panel);
  };
  n.prototype.showShowNodePanel = function(a) {
    function b() {
      panel.content.innerHTML = "";
      panel.addHTML("<span class='node_type'>" + a.type + "</span><span class='node_desc'>" + (a.constructor.desc || "") + "</span><span class='separator'></span>");
      panel.addHTML("<h3>Properties</h3>");
      var b = function(b, c) {
        e.graph.beforeChange(a);
        switch(b) {
          case "Title":
            a.title = c;
            break;
          case "Mode":
            b = Object.values(g.NODE_MODES).indexOf(c);
            0 <= b && g.NODE_MODES[b] ? a.changeMode(b) : console.warn("unexpected mode: " + c);
            break;
          case "Color":
            n.node_colors[c] ? (a.color = w(n.node_colors[c].color, 0.5), a.bgcolor = w(n.node_colors[c].bgcolor, 0.5)) : console.warn("unexpected color: " + c);
            break;
          default:
            a.setProperty(b, c);
        }
        e.graph.afterChange();
        e.dirty_canvas = !0;
      };
      panel.addWidget("string", "Title", a.title, {}, b);
      panel.addWidget("combo", "Mode", g.NODE_MODES[a.mode], {values:g.NODE_MODES}, b);
      var c = "";
      void 0 !== a.color && (c = Object.keys(n.node_colors).filter(function(b) {
        return n.node_colors[b].color == a.color;
      }));
      panel.addWidget("combo", "Color", c, {values:Object.keys(n.node_colors)}, b);
      for (var h in a.properties) {
        c = a.properties[h];
        var k = a.getPropertyInfo(h);
        a.onAddPropertyToPanel && a.onAddPropertyToPanel(h, panel) || panel.addWidget(k.widget || k.type, h, c, k, b);
      }
      panel.addSeparator();
      if (a.onShowCustomPanelInfo) {
        a.onShowCustomPanelInfo(panel);
      }
      panel.footer.innerHTML = "";
      panel.addButton("Delete", function() {
        a.block_delete || (a.graph.remove(a), panel.close());
      }).classList.add("delete");
    }
    this.SELECTED_NODE = a;
    this.closePanels();
    var c = this.getCanvasWindow(), e = this;
    panel = this.createPanel(a.title || "", {closable:!0, window:c, onOpen:function() {
      e.NODEPANEL_IS_OPEN = !0;
    }, onClose:function() {
      e.NODEPANEL_IS_OPEN = !1;
      e.node_panel = null;
    }});
    e.node_panel = panel;
    panel.id = "node-panel";
    panel.node = a;
    panel.classList.add("settings");
    panel.inner_showCodePad = function(c) {
      panel.classList.remove("settings");
      panel.classList.add("centered");
      panel.alt_content.innerHTML = "<textarea class='code'></textarea>";
      var d = panel.alt_content.querySelector("textarea"), e = function() {
        panel.toggleAltContent(!1);
        panel.toggleFooterVisibility(!0);
        d.parentNode.removeChild(d);
        panel.classList.add("settings");
        panel.classList.remove("centered");
        b();
      };
      d.value = a.properties[c];
      d.addEventListener("keydown", function(b) {
        "Enter" == b.code && b.ctrlKey && (a.setProperty(c, d.value), e());
      });
      panel.toggleAltContent(!0);
      panel.toggleFooterVisibility(!1);
      d.style.height = "calc(100% - 40px)";
      var g = panel.addButton("Assign", function() {
        a.setProperty(c, d.value);
        e();
      });
      panel.alt_content.appendChild(g);
      g = panel.addButton("Close", e);
      g.style.float = "right";
      panel.alt_content.appendChild(g);
    };
    b();
    this.canvas.parentNode.appendChild(panel);
  };
  n.prototype.showSubgraphPropertiesDialog = function(a) {
    function b() {
      e.clear();
      if (a.inputs) {
        for (var c = 0; c < a.inputs.length; ++c) {
          var f = a.inputs[c];
          if (!f.not_subgraph_input) {
            var g = e.addHTML("<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>", "subgraph_property");
            g.dataset.name = f.name;
            g.dataset.slot = c;
            g.querySelector(".name").innerText = f.name;
            g.querySelector(".type").innerText = f.type;
            g.querySelector("button").addEventListener("click", function(c) {
              a.removeInput(Number(this.parentNode.dataset.slot));
              b();
            });
          }
        }
      }
    }
    console.log("showing subgraph properties dialog");
    var c = this.canvas.parentNode.querySelector(".subgraph_dialog");
    c && c.close();
    var e = this.createPanel("Subgraph Inputs", {closable:!0, width:500});
    e.node = a;
    e.classList.add("subgraph_dialog");
    e.addHTML(" + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>", "subgraph_property extra", !0).querySelector("button").addEventListener("click", function(c) {
      c = this.parentNode;
      var d = c.querySelector(".name").value, e = c.querySelector(".type").value;
      d && -1 == a.findInputSlot(d) && (a.addInput(d, e), c.querySelector(".name").value = "", c.querySelector(".type").value = "", b());
    });
    b();
    this.canvas.parentNode.appendChild(e);
    return e;
  };
  n.prototype.showSubgraphPropertiesDialogRight = function(a) {
    function b() {
      d.clear();
      if (a.outputs) {
        for (var c = 0; c < a.outputs.length; ++c) {
          var e = a.outputs[c];
          if (!e.not_subgraph_output) {
            var g = d.addHTML("<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>", "subgraph_property");
            g.dataset.name = e.name;
            g.dataset.slot = c;
            g.querySelector(".name").innerText = e.name;
            g.querySelector(".type").innerText = e.type;
            g.querySelector("button").addEventListener("click", function(c) {
              a.removeOutput(Number(this.parentNode.dataset.slot));
              b();
            });
          }
        }
      }
    }
    function c() {
      var c = this.parentNode, d = c.querySelector(".name").value, e = c.querySelector(".type").value;
      d && -1 == a.findOutputSlot(d) && (a.addOutput(d, e), c.querySelector(".name").value = "", c.querySelector(".type").value = "", b());
    }
    var e = this.canvas.parentNode.querySelector(".subgraph_dialog");
    e && e.close();
    var d = this.createPanel("Subgraph Outputs", {closable:!0, width:500});
    d.node = a;
    d.classList.add("subgraph_dialog");
    e = d.addHTML(" + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>", "subgraph_property extra", !0);
    e.querySelector(".name").addEventListener("keydown", function(a) {
      13 == a.keyCode && c.apply(this);
    });
    e.querySelector("button").addEventListener("click", function(a) {
      c.apply(this);
    });
    b();
    this.canvas.parentNode.appendChild(d);
    return d;
  };
  n.prototype.checkPanels = function() {
    if (this.canvas) {
      for (var a = this.canvas.parentNode.querySelectorAll(".litegraph.dialog"), b = 0; b < a.length; ++b) {
        var c = a[b];
        c.node && (c.node.graph && c.graph == this.graph || c.close());
      }
    }
  };
  n.onMenuNodeCollapse = function(a, b, c, e, d) {
    d.graph.beforeChange();
    a = n.active_canvas;
    if (!a.selected_nodes || 1 >= Object.keys(a.selected_nodes).length) {
      d.collapse();
    } else {
      for (var f in a.selected_nodes) {
        a.selected_nodes[f].collapse();
      }
    }
    d.graph.afterChange();
  };
  n.onMenuNodePin = function(a, b, c, e, d) {
    d.pin();
  };
  n.onMenuNodeMode = function(a, b, c, e, d) {
    new g.ContextMenu(g.NODE_MODES, {event:c, callback:function(a) {
      if (d) {
        var b = Object.values(g.NODE_MODES).indexOf(a), c = function(c) {
          0 <= b && g.NODE_MODES[b] ? c.changeMode(b) : (console.warn("unexpected mode: " + a), c.changeMode(g.ALWAYS));
        }, e = n.active_canvas;
        if (!e.selected_nodes || 1 >= Object.keys(e.selected_nodes).length) {
          c(d);
        } else {
          for (var f in e.selected_nodes) {
            c(e.selected_nodes[f]);
          }
        }
      }
    }, parentMenu:e, node:d});
    return !1;
  };
  n.onMenuNodeColors = function(a, b, c, e, d) {
    if (!d) {
      throw "no node for color";
    }
    b = [];
    b.push({value:null, content:"<span style='display: block; padding-left: 4px;'>No color</span>"});
    for (var f in n.node_colors) {
      a = n.node_colors[f], a = {value:f, content:"<span style='display: block; color: #999; padding-left: 4px; border-left: 8px solid " + a.color + "; background-color:" + a.bgcolor + "'>" + f + "</span>"}, b.push(a);
    }
    new g.ContextMenu(b, {event:c, callback:function(a) {
      if (d) {
        var b = a.value ? n.node_colors[a.value] : null;
        a = function(a) {
          b ? a.constructor === g.LGraphGroup ? a.color = b.groupcolor : (a.color = w(b.color, 0.5), a.bgcolor = w(b.bgcolor, 0.5)) : (delete a.color, delete a.bgcolor);
        };
        var c = n.active_canvas;
        if (!c.selected_nodes || 1 >= Object.keys(c.selected_nodes).length) {
          a(d);
        } else {
          for (var e in c.selected_nodes) {
            a(c.selected_nodes[e]);
          }
        }
        d.setDirtyCanvas(!0, !0);
      }
    }, parentMenu:e, node:d});
    return !1;
  };
  n.onMenuNodeShapes = function(a, b, c, e, d) {
    if (!d) {
      throw "no node passed";
    }
    new g.ContextMenu(g.VALID_SHAPES, {event:c, callback:function(a) {
      if (d) {
        d.graph.beforeChange();
        var b = n.active_canvas;
        if (!b.selected_nodes || 1 >= Object.keys(b.selected_nodes).length) {
          d.shape = a;
        } else {
          for (var c in b.selected_nodes) {
            b.selected_nodes[c].shape = a;
          }
        }
        d.graph.afterChange();
        d.setDirtyCanvas(!0);
      }
    }, parentMenu:e, node:d});
    return !1;
  };
  n.onMenuNodeRemove = function(a, b, c, e, d) {
    if (!d) {
      throw "no node passed";
    }
    a = d.graph;
    a.beforeChange();
    b = n.active_canvas;
    if (!b.selected_nodes || 1 >= Object.keys(b.selected_nodes).length) {
      !1 !== d.removable && a.remove(d);
    } else {
      for (var f in b.selected_nodes) {
        c = b.selected_nodes[f], !1 !== c.removable && a.remove(c);
      }
    }
    a.afterChange();
    d.setDirtyCanvas(!0, !0);
  };
  n.onMenuNodeToSubgraph = function(a, b, c, e, d) {
    a = d.graph;
    if (b = n.active_canvas) {
      c = Object.values(b.selected_nodes || {}), c.length || (c = [d]), e = g.createNode("graph/subgraph"), e.pos = d.pos.concat(), a.add(e), e.buildFromNodes(c), b.deselectAllNodes(), d.setDirtyCanvas(!0, !0);
    }
  };
  n.onMenuNodeClone = function(a, b, c, e, d) {
    d.graph.beforeChange();
    var f = {};
    a = function(a) {
      if (0 != a.clonable) {
        var b = a.clone();
        b && (b.pos = [a.pos[0] + 5, a.pos[1] + 5], a.graph.add(b), f[b.id] = b);
      }
    };
    b = n.active_canvas;
    if (!b.selected_nodes || 1 >= Object.keys(b.selected_nodes).length) {
      a(d);
    } else {
      for (var g in b.selected_nodes) {
        a(b.selected_nodes[g]);
      }
    }
    Object.keys(f).length && b.selectNodes(f);
    d.graph.afterChange();
    d.setDirtyCanvas(!0, !0);
  };
  n.node_colors = {red:{color:"#322", bgcolor:"#533", groupcolor:"#A88"}, brown:{color:"#332922", bgcolor:"#593930", groupcolor:"#b06634"}, green:{color:"#232", bgcolor:"#353", groupcolor:"#8A8"}, blue:{color:"#223", bgcolor:"#335", groupcolor:"#88A"}, pale_blue:{color:"#2a363b", bgcolor:"#3f5159", groupcolor:"#3f789e"}, cyan:{color:"#233", bgcolor:"#355", groupcolor:"#8AA"}, purple:{color:"#323", bgcolor:"#535", groupcolor:"#a1309b"}, yellow:{color:"#432", bgcolor:"#653", groupcolor:"#b58b2a"}, 
  black:{color:"#222", bgcolor:"#000", groupcolor:"#444"}};
  n.prototype.getCanvasMenuOptions = function() {
    if (this.getMenuOptions) {
      var a = this.getMenuOptions();
    } else {
      a = [{content:"Add Node", has_submenu:!0, callback:n.onMenuAdd}, {content:"Add Group", callback:n.onGroupAdd}], this._graph_stack && 0 < this._graph_stack.length && a.push(null, {content:"Close subgraph", callback:this.closeSubgraph.bind(this)});
    }
    if (this.getExtraMenuOptions) {
      var b = this.getExtraMenuOptions(this, a);
      b && (a = a.concat(b));
    }
    return a;
  };
  n.prototype.getNodeMenuOptions = function(a) {
    if (a.getMenuOptions) {
      var b = a.getMenuOptions(this);
    } else {
      b = [{content:"Inputs", has_submenu:!0, disabled:!0, callback:n.showMenuNodeOptionalInputs}, {content:"Outputs", has_submenu:!0, disabled:!0, callback:n.showMenuNodeOptionalOutputs}, null, {content:"Properties", has_submenu:!0, callback:n.onShowMenuNodeProperties}, null, {content:"Title", callback:n.onShowPropertyEditor}, {content:"Mode", has_submenu:!0, callback:n.onMenuNodeMode}], !1 !== a.resizable && b.push({content:"Resize", callback:n.onMenuResizeNode}), b.push({content:"Collapse", callback:n.onMenuNodeCollapse}, 
      {content:"Pin", callback:n.onMenuNodePin}, {content:"Colors", has_submenu:!0, callback:n.onMenuNodeColors}, {content:"Shapes", has_submenu:!0, callback:n.onMenuNodeShapes}, null);
    }
    if (a.onGetInputs) {
      var c = a.onGetInputs();
      c && c.length && (b[0].disabled = !1);
    }
    a.onGetOutputs && (c = a.onGetOutputs()) && c.length && (b[1].disabled = !1);
    a.getExtraMenuOptions && (c = a.getExtraMenuOptions(this, b)) && (c.push(null), b = c.concat(b));
    !1 !== a.clonable && b.push({content:"Clone", callback:n.onMenuNodeClone});
    b.push(null, {content:"Remove", disabled:!(!1 !== a.removable && !a.block_delete), callback:n.onMenuNodeRemove});
    if (a.graph && a.graph.onGetNodeMenuOptions) {
      a.graph.onGetNodeMenuOptions(b, a);
    }
    return b;
  };
  n.prototype.getGroupMenuOptions = function(a) {
    return [{content:"Title", callback:n.onShowPropertyEditor}, {content:"Color", has_submenu:!0, callback:n.onMenuNodeColors}, {content:"Font size", property:"font_size", type:"Number", callback:n.onShowPropertyEditor}, null, {content:"Remove", callback:n.onMenuNodeRemove}];
  };
  n.prototype.processContextMenu = function(a, b) {
    var c = this, e = n.active_canvas.getCanvasWindow(), d = null, f = {event:b, callback:function(b, d, e) {
      if (b) {
        if ("Remove Slot" == b.content) {
          b = b.slot, a.graph.beforeChange(), b.input ? a.removeInput(b.slot) : b.output && a.removeOutput(b.slot), a.graph.afterChange();
        } else {
          if ("Disconnect Links" == b.content) {
            b = b.slot, a.graph.beforeChange(), b.output ? a.disconnectOutput(b.slot) : b.input && a.disconnectInput(b.slot), a.graph.afterChange();
          } else {
            if ("Rename Slot" == b.content) {
              b = b.slot;
              var f = b.input ? a.getInputInfo(b.slot) : a.getOutputInfo(b.slot), g = c.createDialog("<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>", d), h = g.querySelector("input");
              h && f && (h.value = f.label || "");
              var k = function() {
                a.graph.beforeChange();
                h.value && (f && (f.label = h.value), c.setDirty(!0));
                g.close();
                a.graph.afterChange();
              };
              g.querySelector("button").addEventListener("click", k);
              h.addEventListener("keydown", function(a) {
                g.is_modified = !0;
                if (27 == a.keyCode) {
                  g.close();
                } else {
                  if (13 == a.keyCode) {
                    k();
                  } else {
                    if (13 != a.keyCode && "textarea" != a.target.localName) {
                      return;
                    }
                  }
                }
                a.preventDefault();
                a.stopPropagation();
              });
              h.focus();
            }
          }
        }
      }
    }, extra:a};
    a && (f.title = a.type);
    var h = null;
    a && (h = a.getSlotInPosition(b.canvasX, b.canvasY), n.active_node = a);
    h ? (d = [], a.getSlotMenuOptions ? d = a.getSlotMenuOptions(h) : (h && h.output && h.output.links && h.output.links.length && d.push({content:"Disconnect Links", slot:h}), b = h.input || h.output, b.removable && d.push(b.locked ? "Cannot remove" : {content:"Remove Slot", slot:h}), b.nameLocked || d.push({content:"Rename Slot", slot:h})), f.title = (h.input ? h.input.type : h.output.type) || "*", h.input && h.input.type == g.ACTION && (f.title = "Action"), h.output && h.output.type == g.EVENT && 
    (f.title = "Event")) : a ? d = this.getNodeMenuOptions(a) : (d = this.getCanvasMenuOptions(), (h = this.graph.getGroupOnPos(b.canvasX, b.canvasY)) && d.push(null, {content:"Edit Group", has_submenu:!0, submenu:{title:"Group", extra:h, options:this.getGroupMenuOptions(h)}}));
    d && new g.ContextMenu(d, f, e);
  };
  "undefined" != typeof window && window.CanvasRenderingContext2D && !window.CanvasRenderingContext2D.prototype.roundRect && (window.CanvasRenderingContext2D.prototype.roundRect = function(a, b, c, e, d, f) {
    var g, k;
    if (0 === d) {
      this.rect(a, b, c, e);
    } else {
      void 0 === f && (f = d);
      if (null != d && d.constructor === Array) {
        if (1 == d.length) {
          var n = g = k = f = d[0];
        } else {
          if (2 == d.length) {
            n = f = d[0], g = k = d[1];
          } else {
            if (4 == d.length) {
              n = d[0], g = d[1], k = d[2], f = d[3];
            } else {
              return;
            }
          }
        }
      } else {
        n = d || 0, g = d || 0, k = f || 0, f = f || 0;
      }
      this.moveTo(a + n, b);
      this.lineTo(a + c - g, b);
      this.quadraticCurveTo(a + c, b, a + c, b + g);
      this.lineTo(a + c, b + e - f);
      this.quadraticCurveTo(a + c, b + e, a + c - f, b + e);
      this.lineTo(a + f, b + e);
      this.quadraticCurveTo(a, b + e, a, b + e - k);
      this.lineTo(a, b + k);
      this.quadraticCurveTo(a, b, a + n, b);
    }
  });
  g.compareObjects = function(a, b) {
    for (var c in a) {
      if (a[c] != b[c]) {
        return !1;
      }
    }
    return !0;
  };
  g.distance = G;
  g.colorToString = function(a) {
    return "rgba(" + Math.round(255 * a[0]).toFixed() + "," + Math.round(255 * a[1]).toFixed() + "," + Math.round(255 * a[2]).toFixed() + "," + (4 == a.length ? a[3].toFixed(2) : "1.0") + ")";
  };
  g.isInsideRectangle = B;
  g.growBounding = function(a, b, c) {
    b < a[0] ? a[0] = b : b > a[2] && (a[2] = b);
    c < a[1] ? a[1] = c : c > a[3] && (a[3] = c);
  };
  g.isInsideBounding = function(a, b) {
    return a[0] < b[0][0] || a[1] < b[0][1] || a[0] > b[1][0] || a[1] > b[1][1] ? !1 : !0;
  };
  g.overlapBounding = H;
  g.hex2num = function(a) {
    "#" == a.charAt(0) && (a = a.slice(1));
    a = a.toUpperCase();
    for (var b = Array(3), c = 0, e, d, f = 0; 6 > f; f += 2) {
      e = "0123456789ABCDEF".indexOf(a.charAt(f)), d = "0123456789ABCDEF".indexOf(a.charAt(f + 1)), b[c] = 16 * e + d, c++;
    }
    return b;
  };
  g.num2hex = function(a) {
    for (var b = "#", c, e, d = 0; 3 > d; d++) {
      c = a[d] / 16, e = a[d] % 16, b += "0123456789ABCDEF".charAt(c) + "0123456789ABCDEF".charAt(e);
    }
    return b;
  };
  F.prototype.addItem = function(a, b, c) {
    function e(a) {
      var b = this.value;
      b && b.has_submenu && d.call(this, a);
    }
    function d(a) {
      var b = this.value, d = !0;
      f.current_submenu && f.current_submenu.close(a);
      if (c.callback) {
        var e = c.callback.call(this, b, c, a, f, c.node);
        !0 === e && (d = !1);
      }
      if (b && (b.callback && !c.ignore_item_callbacks && !0 !== b.disabled && (e = b.callback.call(this, b, c, a, f, c.extra), !0 === e && (d = !1)), b.submenu)) {
        if (!b.submenu.options) {
          throw "ContextMenu submenu needs options";
        }
        new f.constructor(b.submenu.options, {callback:b.submenu.callback, event:a, parentMenu:f, ignore_item_callbacks:b.submenu.ignore_item_callbacks, title:b.submenu.title, extra:b.submenu.extra, autoopen:c.autoopen});
        d = !1;
      }
      d && !f.lock && f.close();
    }
    var f = this;
    c = c || {};
    var h = document.createElement("div");
    h.className = "litemenu-entry submenu";
    var k = !1;
    if (null === b) {
      h.classList.add("separator");
    } else {
      h.innerHTML = b && b.title ? b.title : a;
      if (h.value = b) {
        b.disabled && (k = !0, h.classList.add("disabled")), (b.submenu || b.has_submenu) && h.classList.add("has_submenu");
      }
      "function" == typeof b ? (h.dataset.value = a, h.onclick_callback = b) : h.dataset.value = b;
      b.className && (h.className += " " + b.className);
    }
    this.root.appendChild(h);
    k || h.addEventListener("click", d);
    c.autoopen && g.pointerListenerAdd(h, "enter", e);
    return h;
  };
  F.prototype.close = function(a, b) {
    this.root.parentNode && this.root.parentNode.removeChild(this.root);
    this.parentMenu && !b && (this.parentMenu.lock = !1, this.parentMenu.current_submenu = null, void 0 === a ? this.parentMenu.close() : a && !F.isCursorOverElement(a, this.parentMenu.root) && F.trigger(this.parentMenu.root, g.pointerevents_method + "leave", a));
    this.current_submenu && this.current_submenu.close(a, !0);
    this.root.closing_timer && clearTimeout(this.root.closing_timer);
  };
  F.trigger = function(a, b, c, e) {
    var d = document.createEvent("CustomEvent");
    d.initCustomEvent(b, !0, !0, c);
    d.srcElement = e;
    a.dispatchEvent ? a.dispatchEvent(d) : a.__events && a.__events.dispatchEvent(d);
    return d;
  };
  F.prototype.getTopMenu = function() {
    return this.options.parentMenu ? this.options.parentMenu.getTopMenu() : this;
  };
  F.prototype.getFirstEvent = function() {
    return this.options.parentMenu ? this.options.parentMenu.getFirstEvent() : this.options.event;
  };
  F.isCursorOverElement = function(a, b) {
    var c = a.clientX;
    a = a.clientY;
    return (b = b.getBoundingClientRect()) ? a > b.top && a < b.top + b.height && c > b.left && c < b.left + b.width ? !0 : !1 : !1;
  };
  g.ContextMenu = F;
  g.closeAllContextMenus = function(a) {
    a = a || window;
    a = a.document.querySelectorAll(".litecontextmenu");
    if (a.length) {
      for (var b = [], c = 0; c < a.length; c++) {
        b.push(a[c]);
      }
      for (c = 0; c < b.length; c++) {
        b[c].close ? b[c].close() : b[c].parentNode && b[c].parentNode.removeChild(b[c]);
      }
    }
  };
  g.extendClass = function(a, b) {
    for (var c in b) {
      a.hasOwnProperty(c) || (a[c] = b[c]);
    }
    if (b.prototype) {
      for (c in b.prototype) {
        b.prototype.hasOwnProperty(c) && !a.prototype.hasOwnProperty(c) && (b.prototype.__lookupGetter__(c) ? a.prototype.__defineGetter__(c, b.prototype.__lookupGetter__(c)) : a.prototype[c] = b.prototype[c], b.prototype.__lookupSetter__(c) && a.prototype.__defineSetter__(c, b.prototype.__lookupSetter__(c)));
      }
    }
  };
  D.sampleCurve = function(a, b) {
    if (b) {
      for (var c = 0; c < b.length - 1; ++c) {
        var e = b[c], d = b[c + 1];
        if (!(d[0] < a)) {
          b = d[0] - e[0];
          if (0.00001 > Math.abs(b)) {
            return e[1];
          }
          a = (a - e[0]) / b;
          return e[1] * (1.0 - a) + d[1] * a;
        }
      }
      return 0;
    }
  };
  D.prototype.draw = function(a, b, c, e, d, f) {
    if (c = this.points) {
      this.size = b;
      var g = b[0] - 2 * this.margin;
      b = b[1] - 2 * this.margin;
      d = d || "#666";
      a.save();
      a.translate(this.margin, this.margin);
      e && (a.fillStyle = "#111", a.fillRect(0, 0, g, b), a.fillStyle = "#222", a.fillRect(0.5 * g, 0, 1, b), a.strokeStyle = "#333", a.strokeRect(0, 0, g, b));
      a.strokeStyle = d;
      f && (a.globalAlpha = 0.5);
      a.beginPath();
      for (e = 0; e < c.length; ++e) {
        d = c[e], a.lineTo(d[0] * g, (1.0 - d[1]) * b);
      }
      a.stroke();
      a.globalAlpha = 1;
      if (!f) {
        for (e = 0; e < c.length; ++e) {
          d = c[e], a.fillStyle = this.selected == e ? "#FFF" : this.nearest == e ? "#DDD" : "#AAA", a.beginPath(), a.arc(d[0] * g, (1.0 - d[1]) * b, 2, 0, 2 * Math.PI), a.fill();
        }
      }
      a.restore();
    }
  };
  D.prototype.onMouseDown = function(a, b) {
    var c = this.points;
    if (c && !(0 > a[1])) {
      var e = this.size[0] - 2 * this.margin, d = this.size[1] - 2 * this.margin, f = a[0] - this.margin;
      a = a[1] - this.margin;
      this.selected = this.getCloserPoint([f, a], 30 / b.ds.scale);
      -1 == this.selected && (b = [f / e, 1 - a / d], c.push(b), c.sort(function(a, b) {
        return a[0] - b[0];
      }), this.selected = c.indexOf(b), this.must_update = !0);
      if (-1 != this.selected) {
        return !0;
      }
    }
  };
  D.prototype.onMouseMove = function(a, b) {
    var c = this.points;
    if (c) {
      var e = this.selected;
      if (!(0 > e)) {
        var d = (a[0] - this.margin) / (this.size[0] - 2 * this.margin), f = (a[1] - this.margin) / (this.size[1] - 2 * this.margin);
        this._nearest = this.getCloserPoint([a[0] - this.margin, a[1] - this.margin], 30 / b.ds.scale);
        if (b = c[e]) {
          var g = 0 == e || e == c.length - 1;
          !g && (-10 > a[0] || a[0] > this.size[0] + 10 || -10 > a[1] || a[1] > this.size[1] + 10) ? (c.splice(e, 1), this.selected = -1) : (b[0] = g ? 0 == e ? 0 : 1 : Math.clamp(d, 0, 1), b[1] = 1.0 - Math.clamp(f, 0, 1), c.sort(function(a, b) {
            return a[0] - b[0];
          }), this.selected = c.indexOf(b), this.must_update = !0);
        }
      }
    }
  };
  D.prototype.onMouseUp = function(a, b) {
    this.selected = -1;
    return !1;
  };
  D.prototype.getCloserPoint = function(a, b) {
    var c = this.points;
    if (!c) {
      return -1;
    }
    b = b || 30;
    for (var e = this.size[0] - 2 * this.margin, d = this.size[1] - 2 * this.margin, f = c.length, g = [0, 0], k = 1000000, n = -1, l = 0; l < f; ++l) {
      var x = c[l];
      g[0] = x[0] * e;
      g[1] = (1.0 - x[1]) * d;
      x = vec2.distance(a, g);
      x > k || x > b || (n = l, k = x);
    }
    return n;
  };
  g.CurveEditor = D;
  g.getParameterNames = function(a) {
    return (a + "").replace(/[/][/].*$/gm, "").replace(/\s+/g, "").replace(/[/][*][^/*]*[*][/]/g, "").split("){", 1)[0].replace(/^[^(]*[(]/, "").replace(/=[^,]+/g, "").split(",").filter(Boolean);
  };
  g.pointerListenerAdd = function(a, b, c, e) {
    e = void 0 === e ? !1 : e;
    if (a && a.addEventListener && b && "function" === typeof c) {
      var d = g.pointerevents_method;
      if ("pointer" == d && !window.PointerEvent) {
        switch(console.warn("sMethod=='pointer' && !window.PointerEvent"), console.log("Converting pointer[" + b + "] : down move up cancel enter TO touchstart touchmove touchend, etc .."), b) {
          case "down":
            d = "touch";
            b = "start";
            break;
          case "move":
            d = "touch";
            break;
          case "up":
            d = "touch";
            b = "end";
            break;
          case "cancel":
            d = "touch";
            break;
          case "enter":
            console.log("debug: Should I send a move event?");
            break;
          default:
            console.warn("PointerEvent not available in this browser ? The event " + b + " would not be called");
        }
      }
      switch(b) {
        case "down":
        case "up":
        case "move":
        case "over":
        case "out":
        case "enter":
          a.addEventListener(d + b, c, e);
        case "leave":
        case "cancel":
        case "gotpointercapture":
        case "lostpointercapture":
          if ("mouse" != d) {
            return a.addEventListener(d + b, c, e);
          }
        default:
          return a.addEventListener(b, c, e);
      }
    }
  };
  g.pointerListenerRemove = function(a, b, c, e) {
    e = void 0 === e ? !1 : e;
    if (a && a.removeEventListener && b && "function" === typeof c) {
      switch(b) {
        case "down":
        case "up":
        case "move":
        case "over":
        case "out":
        case "enter":
          "pointer" != g.pointerevents_method && "mouse" != g.pointerevents_method || a.removeEventListener(g.pointerevents_method + b, c, e);
        case "leave":
        case "cancel":
        case "gotpointercapture":
        case "lostpointercapture":
          if ("pointer" == g.pointerevents_method) {
            return a.removeEventListener(g.pointerevents_method + b, c, e);
          }
        default:
          return a.removeEventListener(b, c, e);
      }
    }
  };
  Math.clamp = function(a, b, c) {
    return b > a ? b : c < a ? c : a;
  };
  "undefined" == typeof window || window.requestAnimationFrame || (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(a) {
    window.setTimeout(a, 1000 / 60);
  });
})(this);
"undefined" != typeof exports && (exports.LiteGraph = this.LiteGraph);
(function(t) {
  function w() {
    this.size = [140, 80];
    this.properties = {enabled:!0};
    this.enabled = !0;
    this.subgraph = new l.LGraph;
    this.subgraph._subgraph_node = this;
    this.subgraph._is_subgraph = !0;
    this.subgraph.onTrigger = this.onSubgraphTrigger.bind(this);
    this.subgraph.onInputAdded = this.onSubgraphNewInput.bind(this);
    this.subgraph.onInputRenamed = this.onSubgraphRenamedInput.bind(this);
    this.subgraph.onInputTypeChanged = this.onSubgraphTypeChangeInput.bind(this);
    this.subgraph.onInputRemoved = this.onSubgraphRemovedInput.bind(this);
    this.subgraph.onOutputAdded = this.onSubgraphNewOutput.bind(this);
    this.subgraph.onOutputRenamed = this.onSubgraphRenamedOutput.bind(this);
    this.subgraph.onOutputTypeChanged = this.onSubgraphTypeChangeOutput.bind(this);
    this.subgraph.onOutputRemoved = this.onSubgraphRemovedOutput.bind(this);
  }
  function m() {
    this.addOutput("", "number");
    this.name_in_graph = "";
    this.properties = {name:"", type:"number", value:0};
    var l = this;
    this.name_widget = this.addWidget("text", "Name", this.properties.name, function(x) {
      x && l.setProperty("name", x);
    });
    this.type_widget = this.addWidget("text", "Type", this.properties.type, function(x) {
      l.setProperty("type", x);
    });
    this.value_widget = this.addWidget("number", "Value", this.properties.value, function(x) {
      l.setProperty("value", x);
    });
    this.widgets_up = !0;
    this.size = [180, 90];
  }
  function y() {
    this.addInput("", "");
    this.name_in_graph = "";
    this.properties = {name:"", type:""};
    this.name_widget = this.addWidget("text", "Name", this.properties.name, "name");
    this.type_widget = this.addWidget("text", "Type", this.properties.type, "type");
    this.widgets_up = !0;
    this.size = [180, 60];
  }
  var l = t.LiteGraph;
  w.title = "Subgraph";
  w.desc = "Graph inside a node";
  w.title_color = "#334";
  w.prototype.onGetInputs = function() {
    return [["enabled", "boolean"]];
  };
  w.prototype.onDblClick = function(l, m, n) {
    var x = this;
    setTimeout(function() {
      n.openSubgraph(x.subgraph);
    }, 10);
  };
  w.prototype.onAction = function(l, m) {
    this.subgraph.onAction(l, m);
  };
  w.prototype.onExecute = function() {
    if (this.enabled = this.getInputOrProperty("enabled")) {
      if (this.inputs) {
        for (var l = 0; l < this.inputs.length; l++) {
          var m = this.inputs[l], n = this.getInputData(l);
          this.subgraph.setInputData(m.name, n);
        }
      }
      this.subgraph.runStep();
      if (this.outputs) {
        for (l = 0; l < this.outputs.length; l++) {
          n = this.subgraph.getOutputData(this.outputs[l].name), this.setOutputData(l, n);
        }
      }
    }
  };
  w.prototype.sendEventToAllNodes = function(l, m, n) {
    this.enabled && this.subgraph.sendEventToAllNodes(l, m, n);
  };
  w.prototype.onDrawBackground = function(m, t, n, w) {
    this.flags.collapsed || (t = this.size[1] - l.NODE_TITLE_HEIGHT + 0.5, n = l.isInsideRectangle(w[0], w[1], this.pos[0], this.pos[1] + t, this.size[0], l.NODE_TITLE_HEIGHT), w = l.isInsideRectangle(w[0], w[1], this.pos[0], this.pos[1] + t, this.size[0] / 2, l.NODE_TITLE_HEIGHT), m.fillStyle = n ? "#555" : "#222", m.beginPath(), this._shape == l.BOX_SHAPE ? w ? m.rect(0, t, this.size[0] / 2 + 1, l.NODE_TITLE_HEIGHT) : m.rect(this.size[0] / 2, t, this.size[0] / 2 + 1, l.NODE_TITLE_HEIGHT) : w ? 
    m.roundRect(0, t, this.size[0] / 2 + 1, l.NODE_TITLE_HEIGHT, [0, 0, 8, 8]) : m.roundRect(this.size[0] / 2, t, this.size[0] / 2 + 1, l.NODE_TITLE_HEIGHT, [0, 0, 8, 8]), n ? m.fill() : m.fillRect(0, t, this.size[0] + 1, l.NODE_TITLE_HEIGHT), m.textAlign = "center", m.font = "24px Arial", m.fillStyle = n ? "#DDD" : "#999", m.fillText("+", 0.25 * this.size[0], t + 24), m.fillText("+", 0.75 * this.size[0], t + 24));
  };
  w.prototype.onMouseDown = function(m, t, n) {
    m = this.size[1] - l.NODE_TITLE_HEIGHT + 0.5;
    console.log(0);
    t[1] > m && (t[0] < this.size[0] / 2 ? (console.log(1), n.showSubgraphPropertiesDialog(this)) : (console.log(2), n.showSubgraphPropertiesDialogRight(this)));
  };
  w.prototype.computeSize = function() {
    return [200, Math.max(this.inputs ? this.inputs.length : 0, this.outputs ? this.outputs.length : 0) * l.NODE_SLOT_HEIGHT + l.NODE_TITLE_HEIGHT];
  };
  w.prototype.onSubgraphTrigger = function(l, m) {
    l = this.findOutputSlot(l);
    -1 != l && this.triggerSlot(l);
  };
  w.prototype.onSubgraphNewInput = function(l, m) {
    -1 == this.findInputSlot(l) && this.addInput(l, m);
  };
  w.prototype.onSubgraphRenamedInput = function(l, m) {
    l = this.findInputSlot(l);
    -1 != l && (this.getInputInfo(l).name = m);
  };
  w.prototype.onSubgraphTypeChangeInput = function(l, m) {
    l = this.findInputSlot(l);
    -1 != l && (this.getInputInfo(l).type = m);
  };
  w.prototype.onSubgraphRemovedInput = function(l) {
    l = this.findInputSlot(l);
    -1 != l && this.removeInput(l);
  };
  w.prototype.onSubgraphNewOutput = function(l, m) {
    -1 == this.findOutputSlot(l) && this.addOutput(l, m);
  };
  w.prototype.onSubgraphRenamedOutput = function(l, m) {
    l = this.findOutputSlot(l);
    -1 != l && (this.getOutputInfo(l).name = m);
  };
  w.prototype.onSubgraphTypeChangeOutput = function(l, m) {
    l = this.findOutputSlot(l);
    -1 != l && (this.getOutputInfo(l).type = m);
  };
  w.prototype.onSubgraphRemovedOutput = function(l) {
    l = this.findInputSlot(l);
    -1 != l && this.removeOutput(l);
  };
  w.prototype.getExtraMenuOptions = function(l) {
    var m = this;
    return [{content:"Open", callback:function() {
      l.openSubgraph(m.subgraph);
    }}];
  };
  w.prototype.onResize = function(l) {
    l[1] += 20;
  };
  w.prototype.serialize = function() {
    var m = l.LGraphNode.prototype.serialize.call(this);
    m.subgraph = this.subgraph.serialize();
    return m;
  };
  w.prototype.clone = function() {
    var m = l.createNode(this.type), t = this.serialize();
    delete t.id;
    delete t.inputs;
    delete t.outputs;
    m.configure(t);
    return m;
  };
  w.prototype.buildFromNodes = function(l) {
    for (var m = {}, n = 0; n < l.length; ++n) {
      var t = l[n];
      m[t.id] = t;
    }
    for (n = 0; n < l.length; ++n) {
      t = l[n];
      if (t.inputs) {
        for (var x = 0; x < t.inputs.length; ++x) {
          var w = t.inputs[x];
          if (w && w.link) {
            var y = t.graph.links[w.link];
            y && (m[y.origin_id] || this.subgraph.addInput(w.name, y.type));
          }
        }
      }
      if (t.outputs) {
        for (x = 0; x < t.outputs.length; ++x) {
          if ((w = t.outputs[x]) && w.links && w.links.length) {
            for (var D = 0; D < w.links.length && (!(y = t.graph.links[w.links[D]]) || m[y.target_id]); ++D) {
            }
          }
        }
      }
    }
  };
  l.Subgraph = w;
  l.registerNodeType("graph/subgraph", w);
  m.title = "Input";
  m.desc = "Input of the graph";
  m.prototype.onConfigure = function() {
    this.updateType();
  };
  m.prototype.updateType = function() {
    var m = this.properties.type;
    this.type_widget.value = m;
    this.outputs[0].type != m && (l.isValidConnection(this.outputs[0].type, m) || this.disconnectOutput(0), this.outputs[0].type = m);
    "number" == m ? (this.value_widget.type = "number", this.value_widget.value = 0) : "boolean" == m ? (this.value_widget.type = "toggle", this.value_widget.value = !0) : "string" == m ? (this.value_widget.type = "text", this.value_widget.value = "") : (this.value_widget.type = null, this.value_widget.value = null);
    this.properties.value = this.value_widget.value;
    this.graph && this.name_in_graph && this.graph.changeInputType(this.name_in_graph, m);
  };
  m.prototype.onPropertyChanged = function(l, m) {
    if ("name" == l) {
      if ("" == m || m == this.name_in_graph || "enabled" == m) {
        return !1;
      }
      this.graph && (this.name_in_graph ? this.graph.renameInput(this.name_in_graph, m) : this.graph.addInput(m, this.properties.type));
      this.name_in_graph = this.name_widget.value = m;
    } else {
      "type" == l && this.updateType();
    }
  };
  m.prototype.getTitle = function() {
    return this.flags.collapsed ? this.properties.name : this.title;
  };
  m.prototype.onAction = function(m, t) {
    this.properties.type == l.EVENT && this.triggerSlot(0, t);
  };
  m.prototype.onExecute = function() {
    var l = this.graph.inputs[this.properties.name];
    l ? this.setOutputData(0, void 0 !== l.value ? l.value : this.properties.value) : this.setOutputData(0, this.properties.value);
  };
  m.prototype.onRemoved = function() {
    this.name_in_graph && this.graph.removeInput(this.name_in_graph);
  };
  l.GraphInput = m;
  l.registerNodeType("graph/input", m);
  y.title = "Output";
  y.desc = "Output of the graph";
  y.prototype.onPropertyChanged = function(l, m) {
    if ("name" == l) {
      if ("" == m || m == this.name_in_graph || "enabled" == m) {
        return !1;
      }
      this.graph && (this.name_in_graph ? this.graph.renameOutput(this.name_in_graph, m) : this.graph.addOutput(m, this.properties.type));
      this.name_in_graph = this.name_widget.value = m;
    } else {
      "type" == l && this.updateType();
    }
  };
  y.prototype.updateType = function() {
    var m = this.properties.type;
    this.type_widget && (this.type_widget.value = m);
    if (this.inputs[0].type != m) {
      if ("action" == m || "event" == m) {
        m = l.EVENT;
      }
      l.isValidConnection(this.inputs[0].type, m) || this.disconnectInput(0);
      this.inputs[0].type = m;
    }
    this.graph && this.name_in_graph && this.graph.changeOutputType(this.name_in_graph, m);
  };
  y.prototype.onExecute = function() {
    this._value = this.getInputData(0);
    this.graph.setOutputData(this.properties.name, this._value);
  };
  y.prototype.onAction = function(m, t) {
    this.properties.type == l.ACTION && this.graph.trigger(this.properties.name, t);
  };
  y.prototype.onRemoved = function() {
    this.name_in_graph && this.graph.removeOutput(this.name_in_graph);
  };
  y.prototype.getTitle = function() {
    return this.flags.collapsed ? this.properties.name : this.title;
  };
  l.GraphOutput = y;
  l.registerNodeType("graph/output", y);
})(this);

